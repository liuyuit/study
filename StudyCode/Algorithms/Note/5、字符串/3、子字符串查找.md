# 子字符串查找

给定一段长度为 N 的文本和一个长度为 M 的模式（pattern）字符串。在文本中找到一个和该模式相同的子字符串。

## 历史简介

## 暴力子字符串查找算法

```
<?php

function search($pat, $txt){
    $M = strlen($pat);
    $N = strlen($txt);

    for ($i = 0; $i <= $N - $M; $i++){ // 从 0 到 N - M 开始对每个位置进行对比
        for ($j = 0; $j < $M; $j++){ // 开始对比 txt 的第 i 个位置，需要将 pat 的每个字符与 txt 相应位置的字符进行对比
            if ($txt[$i + $j] != $pat[$j]){ // txt 的第 i + j 个字符相对应的就是 pat 第 j 个字符
                break;
            }
        }

        if ($j == $M){
            return $i; // 找到匹配
        }
    }

    return $N; // 未找到匹配
}


echo search('as', 'ag112123asd1');
```

显式回退

```
<?php

function search($pat, $txt){
    $M = strlen($pat);
    $N = strlen($txt);

   for ($i = 0, $j = 0; $i < $N && $j < $M; $i++){ // i 跟踪文本，j 跟踪模式
       if ($txt[$i] == $pat[$j]){
           $j++; // 如果相等，就在下一次循环中比较 pat 的下一个字符，txt 也会比较下一个字符。直到 j = M 时会不满足循环条件然后跳出循环，即表示匹配成功
       } else { // 如果不相等，i 需要回退到这一次匹配开始时的位置，然后在下一个循环进入下一个位置。 同时 j 也重置为 0；
           $i -= $j;
           $j = 0;
       }
   }

   if ($j == $M){
       return $i - $M; // 找到匹配
   } else {
       return $N; // 未找到匹配
   }
}


echo search('as', 'ag112123asd1');
```

## Knuth-Morris-Pratt 子字符串查找算法

#### references

> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
>
> http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
>
> https://blog.csdn.net/fpk2014/article/details/80721847
>
> https://zhuanlan.zhihu.com/p/30009083

在匹配失败时，我们总是可以让模式指针回退，而不必回退文本指针。

**有穷自动机**：有一个初始状态，获得满足条件的输入后会进入到下一个状态。达到最终状态的字符串就是就是被这个自动机所接受的字符串。

#### 模式指针的回退

在 KMP 子字符串查找算法中，不会回退文本指针。而是用一个数组 dfa[] [] 来记录匹配失败时模式指针应该回退多远。

#### KMP 查找算法

#### DFA 模拟

#### 构造 DFA

#### Knuth-Morris-Pratt 字符串查找算法

```
<?php
/**
 * ord('a');//=>97 返回小写a 的ascii码值97
 * chr(97);//=>a 返回ascii码表上的97对应的 小写a
 */

function example(){
    $pat = 'aacaa';
    $txt = 'aabaacaaabraaca1';
    $kmp = new KMP($pat);
    $offset = $kmp->search($txt);
    var_dump($offset);
}

example();


/**
 * 用确定有限自动状态机的方式来做子字符串查找
 * Class KMP
 */
class KMP
{
    private $pat = '';
    // [0 => [0 => 0, 1 => 1, 2 => 0]]  外面数组的索引表示在确定有限自动状态机中，下一个输入的字符的 ascii 码。
    // [0 => 0, 1 => 1, 2 => 0] .里面数组的索引表示对于某一个输入的字符，如果当前状态是 key，那么输入这个字符后的状态是 value
    private $dfa = [];

    public function __construct($pat)
    {
        // 由模式字符串构造 DFA;
        $this->pat = $pat;
        $M = strlen($pat);
        $R = 256;
        $this->dfa = $this->iniArray($R, $M);
        $this->dfa[static::charAt($this->pat, 0)][0] = 1; // 如果之前的状态是 0，那么输入 pat 的第一个字符后，状态将变为 1

        for ($X = 0, $j = 1; $j < $M; $j++){
            // 计算 dfa[][$j]
            for ($c = 0; $c < $R; $c++){
                $this->dfa[$c][$j] = $this->dfa[$c][$X]; // 复制匹配失败情况下的值
            }

            $this->dfa[static::charAt($pat, $j)][$j] = $j + 1; // 设置匹配成功情况下的值
            $X = $this->dfa[static::charAt($pat, $j)][$X]; // 更新重启状态
        }
    }

    public function search($txt){
        // 在 txt 上模拟 DFA 的运行
        $N = strlen($txt);
        $M = strlen($this->pat);
        for ($i = 0, $j = 0; $i < $N && $j <$M; $i++){
            $ascii = static::charAt($txt, $i);
            $j = $this->dfa[$ascii][$j];
        }

        if ($j == $M){
            return $i - $M; // 找到匹配（到达模式字符串的结尾）
        } else {
            return $N; // 未找到匹配（到达文本字符串的结尾）
        }
    }

    private function iniArray($m, $n){
        $element = [];

        for ($i = 0; $i < $n; $i++){
            $element[] = 0;
        }

        $array = [];
        for ($i = 0; $i < $m; $i++){
            $array[$i] = $element;
        }

        return $array;
    }

    /**
     * 获取字符串相应位置的字符所对应的 ascii 码，字符串到达末尾了，就返回 -1
     * @param $string string
     * @param $d int
     * @return int|mixed
     */
    private static function charAt($string, $d){
        if ($d < strlen($string)){
            return ord($string[$d]);
        } else {
            return -1;
        }
    }

}
```

## Boyer-Moore 字符串查找算法

在模式字符串和文本进行逐字节匹对时，从最右侧的字符开始对比。模式字符串部分子字符串匹配失败时，右移到模式字符串中相同子字符串的位置。如果模式字符串尾部的子字符串是唯一的。那就将模式字符串整个右移。

#### 启发式的处理不匹配的字符

#### 起点

