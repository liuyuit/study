# 单词查找树

我们可以开发一个更通用的算法，便于以字符串作为被查找的键。

##### 以字符串为键的符号表的API

| StringST        |                                         |
| --------------- | --------------------------------------- |
| StringST        | 创建一个符号表                          |
| put             | 向表中插入键值对                        |
| get             |                                         |
| delete          |                                         |
| contains        | 表中是否保存着key的值                   |
| isEmpty         | 符号表是否为空                          |
| longestPrefixOf | s 的前缀中最长的键                      |
| keysWithPrefix  | 所有以 s 为前缀的键                     |
| keysThatMatch   | 所有和 s 匹配的键（‘.’ 能匹配所有字符） |
| size            | 键值对的数量                            |
| keys            | 符号表中的所有键                        |

对于大型的字母表将会消耗太多的内存，需要再加一个构造函数用于指定字母表。

## 单词查找树

我们需要学习一种叫单词查找树的结构，它由字符串键中的所有字符构造而成，允许使用被查找键中的字符进行查找。这个数据结构的作用是去除数据。

#### 基本性质

单词查找树由链接的结点组成。每一个结点都有 R 条链接。R 为字母表的大小。但每个结点都只有一条指向它的链接，除了根节点。尽管指向的是结点，但也可以看做是以指向的结点为根节点的另一个单词查找树。因为每条链接都只能指向一个结点。所以可以用链接所对应的字符标记指向的结点。

#### 单词查找树的查找操作

单词查找树的每一个结点都有 R 条链接指向了字母表中的所有字符。查找时从根结点出发，先找到首字母所在的结点。再找该结点指向的下一个字符所对应的结点。最后一个结点如果储存了值，则代表查找命中，否则不命中。

#### 单词查找树的插入操作

和二叉查找树一样，插入操作需要先进行一次查找。这意味着沿着被查找的键到达尾字符的结点或者一个空链接，可能会有以下两种情况。

- 到达尾字符之前就遇到一个空链接。需要沿着链接设置结点，到达表示尾字符的结点之后再设置键表示的值。
- 没有遇到空链接。直接在表示尾字符的结点设置值。

#### 结点的表示

数据结构需要将空链接表示出来。

- 每个结点都有 R 个链接，表示所有可能出现的字符。
- 字符和键均隐式地保存在数据结构中

#### 大小

- 即时实现：用一个变量保存键的数量
- 更加即时的实现：用结点的实例变量保存键的数量
- 延时递归实现：遍历所有结点，并记录所有非空结点的总数。

#### 基于单词查找数的符号表

```
<?php
// 在原文的 java 代码中字符和数字相加会自动将字符转化为相应的 ascii 码，在这里需要用 ord 函数来将字符转化为 ascii 码，
// ord('c');
//echo phpinfo();exit;


TrieSTExample();
function TrieSTExample(){
    $a = [
        'she',
        'sells',
        'seashells',
        'by',
        'the',
        'shells',
        'she',
        'shells',
        'are',
        'surely',
        'seashells',
    ];
//    TrieST::sort($a);
    print_r($a);
}

class TrieST
{
    public $R = 256;   // 基数
    public $root; // 单词查找树的根结点


    public function get($key){
        $x = $this->executeGet($this->root, $key, 0);
        if ($x == null){
            return null;
        }
        return $x->val;
    }

    /**
     * @param $x Node
     * @param $key
     * @param $d
     * @return Node|null
     */
    private function executeGet($x, $key, $d){
        if ($x == null){
            return null;
        }

        if ($d == strlen($key)){
            return $x;
        }

        $c = $this->charAt($key, $d);
        return $this->executeGet($x->next[$c], $key, $d);
    }

    public function put($key, $val){
        $this->root = $this->executePut($this->root, $key, $val, 0);
    }

    private function executePut($x, $key, $val, $d){
        if ($x == null){
            $x = new Node();
        }

        if ($d == strlen($key)){
            $x->val = $val;
            return $x;
        }

        $c = $this->charAt($key, $d);
        $x->next[$c] = $this->executePut($x->next[$c], $key, $val, $d + 1);
        return $x;
    }

    public function size(){
        return $this->executeSize($this->root);
    }

    /**
     * 统计一个单词查找数的所有键的数量
     * @param $x Node
     * @return int
     */
    protected function executeSize($x){
        if ($x == null){
            return 0;
        }

        $cnt = 0;
        if ($x->val != null){
            $cnt++; // 有值的结点代表一个键值对
        }

        for ($c = 0; $c < $this->R; $c++){ // 每一个结点都有 R 条链接
            $cnt += $this->executeSize($x->next[$c]); // 把每一个子结点当作一棵子树的根结点，递归地查找子树的键值对数量
        }

        return $cnt;
    }

    public function keys(){
        return $this->keysWithPrefix('');
    }

    public function keysWithPrefix($pre){
        $q = []; // queue
        $this->collect($this->executeGet($this->root, $pre, 0), $pre, $q);
        return $q;
    }

    protected function collect($x, $pre, &$q){
        if ($x == null){
            return;
        }

        if ($x->val != null){
            array_unshift($q, $pre);
        }

        for ($c = 0; $c < $this->R; $c++){
            $this->collect($x->next[$c], $pre + $c, $q);
        }
    }

    /**
     * 获取字符串相应位置的字符所对应的 ascii 码，字符串到达末尾了，就返回 -1
     * @param $string string
     * @param $d int
     * @return int|mixed
     */
    private  function charAt($string, $d){
        if ($d < strlen($string)){
            return ord($string[$d]);
        } else {
            return -1;
        }
    }
}

class Node{
    public $val;
    public $next;
}
```

#### 查找所有键

为查找所有键，我们从根路径出发，递归地访问它的链接数组所指向的所有可能的字符结点。直到访问到一个有值的结点，这条路径的所有结点所代表的字符就组成一个字符串键。

```
  	public function keys(){
        return $this->keysWithPrefix('');
    }

    public function keysWithPrefix($pre){
        $q = []; // queue
        $this->collect($this->executeGet($this->root, $pre, 0), $pre, $q);
        return $q;
    }

    protected function collect($x, $pre, &$q){
        if ($x == null){
            return;
        }

        if ($x->val != null){
            array_unshift($q, $pre);
        }

        for ($c = 0; $c < $this->R; $c++){
            $this->collect($x->next[$c], $pre + $c, $q);
        }
    }

```

#### 通配符匹配

```
    public function keysThatMatch($pat){
        $q = [];
        $this->matchCollect($this->root,'', $pat, $q);
        return $q;
    }

    public function matchCollect($x, $pre, $pat, &$q){
        $d = strlen($pre);

        if ($x == null){
            return;
        }

        if ($d == strlen($pat) && $x->val != null){
             array_unshift($q, $pre);
        }

        if ($d == strlen($pre)){
            return;
        }

        $next = $this->charAt($pat, $d);

        for ($c = 0; $c < $this->R; $c++){
            if ($next == '.' || $next == $c){
                $this->matchCollect($x->next[$c], $pre + $c, $pat, $q);
            }
        }
    }
```

#### 最长前缀

```

    public function longestPrefixOf($s){
        $length = $this->search($this->root, $s, 0, 0);
        return substr($s, 0, $length);
    }

    private function search(Node $x, $s, $d, $length){
        if ($x == null){
            return $length;
        }

        if ($x->val != null){
            $length = $d;
        }
        
        if ($d == strlen($s)){
            return $length;
        }
        
        $c = $this->charAt($s, $d);
        return $this->search($x->next[$c], $s, $d + 1, $length)
    }
```

