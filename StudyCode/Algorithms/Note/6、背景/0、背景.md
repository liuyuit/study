# 背景

在现代社会中算法在以下领域起到关键作用

- 商业应用
- 科学计算
- 工程学
- 运筹学

## 事件驱动模拟

一个基础的科学应用：按照弹性碰撞的原理模拟粒子系统的运动。

#### 刚性球体模型

一个理想的模型，用来描述原子和分子在容器中的运动

- 粒子与墙以及相互之间的碰撞是弹性的
- 粒子是已知位置、速度、质量和直径的球体
- 不存在外力

#### 时间驱动模拟

我们的目标是维持这个模型，即记录所有粒子在任意时间的位置和速度。

因为要考虑到粒子与墙以及相互之间的碰撞。我们使用时间驱动模拟。它使用固定长度的 dt，每次 经过 dt 的时间，都会判断所有的粒子是否有可能相撞，然后还原它们的第一次相撞，再更新它们的速度以反映碰撞的结果。

#### 事件驱动模拟

另一种方式是关注碰撞发生的时间点。记为一个事件。用一个优先级队列来保存所有事件。以事件发生的时间作为优先级。

#### 碰撞预测

// todo

#### 碰撞计算

// todo

#### 排除无效事件

// todo

#### 粒子

// todo

#### 事件

// todo

#### 模拟器代码

// todo

#### 性能

// todo

## B- 树

B- 树 是 3.3 节的平衡树的扩展。

#### 成本模型

**页**：一块连续的数据（一个文件、一个网页、文件的一部分）

**探查**：访问一个页

> B- 树的成本模型：使用页的访问次数（无论读写），作为外部查找算法的成本模型

#### B- 树

B- 树是对 3.3 节所述的 2-3 树的扩展。关键的不同在于：不将数据保存在树中，而是构造一棵由键的副本组成的树，每个副本关联着一条链接。这样可以将符号表与索引本身分开。

#### 约定

外部查找的应用会将数据和索引做隔离。而 B- 树通过以下两种结点来实现。

- 内部结点：含有与键相关联的副本
- 外部结点：含有指向实际数据的引用。

内部结点的每个键都关联一个结点。以此结点为根的子树中，所有键都大于原节点的键，但小于原结点中更大的键（如果有的话）。我们用哨兵键（*），来表示比所有键都小。

#### 查找和插入

B- 树查找的基础是在可能含有被查找键的唯一子树进行递归查找。

B- 树插入和 2-3 树一样，先递归查找到底部，然后在底部插入新键，如果该结点的键超过了限制，就通过分裂来平衡。

#### 数据表示

我们用 Page API 来表示结点

###### B- 树的页的API

| Class | Page         |                                                              |
| ----- | ------------ | ------------------------------------------------------------ |
|       | Page()       | 创建并打开一个也                                             |
|       | close()      |                                                              |
|       | add(Key )    | 将键插入到（外部的）页中                                     |
|       | add(Page)    | 打开 p，向这个（内部）页中插入一个条目，并将 p 和 p 中最小键关联 |
|       | isExternal() | 是否为外部页                                                 |
| Page  | next(Key)    | 可能含有 key 的子树                                          |
|       | ifFull()     | 页是否已经溢出                                               |
| Page  | split()      | 将位置正好大于 M/2 的中间键移动到一个新的 Page 对象中，并返回改对象的引用 |
|       | Keys()       | 页中所有键的迭代器                                           |

#### 性能

// todo

#### 空间需求

// todo

##### B- 树集合的实现

// todo

## 后缀数组

#### 最长重复子字符串

在给定字符串，至少出现两次的最长字符串是什么？例如 ‘to be or not to be’，他的最长重复子字符串就是‘to be’。

#### 暴力解法

找到两个字符串的最长公共前缀

```
<?php

function example(){
    $lcp = new Lcp();
    echo $lcp->execute('asdf123', 'asdf1zxcv');
}
example();

class Lcp
{
    public function execute($s, $t){
        $N = $this->minLength($s, $t);
        for ($i = 0; $i < $N; $i++){
            if($s[$i] != $t[$i]){ // 直到第 i 个字符不相同
                return $i;
            }
        }

        return $N;
    }

    protected function minLength($s, $t){
        if (strlen($s) > strlen($t)){
            $minLength = strlen($t);
        } else {
            $minLength = strlen($s);
        }

        return $minLength;
    }
}
```

#### 后缀排序

先将字符串的所有后缀字符串找出，放入到数组中，然后将数组排序。排序之后具有相同前缀的后缀字符串会相邻，我们只需要统计相邻两个字符串的最长前缀就可以了。这个算法有效的关键在于,所有的子字符串都是这些后缀子字符串的前缀。

#### 定位字符串

在搜索引擎中查找关键字时，就是一次字符串查找。

#### API 及其用例

// todo

#### 实现

// todo

#### 性能

// todo

#### 改进的实现

// todo

## 网络流算法

// todo

