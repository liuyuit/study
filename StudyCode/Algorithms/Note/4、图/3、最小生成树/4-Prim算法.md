# Prim算法

> 一开始只有一个顶点作为最小生成树的一部分，然后将最小生成树和所有不在最小生成树的顶点分为两个集合，将两个集合间相连的边中最小的一个加入到最小生成树中。重复这一步骤，直到所有边都加入到最小生成树。

Prim算法的每一步都会为一棵生长中的树添加一条边。

> 命题L：Prim算法能够得到任意无向加权图的最小生成树
>
> 证明：

## 数据结构

我们需要用以下方法来表示边、顶点、横切边

- 顶点：使用一个由顶点索引的数组marked[]，如果顶点v在树中，那么marked[v] == true;
- 边。可以有以下两种选择：一条mst队列，来保存所有生成树的边。或者一个由顶点索引的edgeTo[]数组，edgeTo[v]为将v连接到树种的edge对象。
- 横切边：使用一条优先队列，来根据权重比较所有边。

## 维护横切边的集合

> - 将一个顶点加入到最小生成树中。
> - 将最小生成树中的所有顶点和不在最小生成树的所有顶点分作两个集合。将新增的连接两个集合的边加入到横切边集合中。
> - 选择横切边集合中最小的边，检查这个边是否有某个顶点在生成树中。
> - 检查通过则将其加入到生成树中
> - 重复这个过程，直到所有顶点都被加入到树中。

算法构造最小生成树的过程如下

- 将任意初始顶点加入到最小生成树中。
- 将初始顶点的所有邻接边加入到优先队列中
- 将最小横切边所连的顶点加入到最小生成树中
- 将新加入顶点的所有邻接边加入到优先队列中
- 将优先队列中连接两个在生成树顶点的边删除掉，因为它们已经不是横切边

这种算法的关键在于将最小生成树中的所有顶点看作一个集合，将所有不在生成树中顶点看作切分的另一个集合，把所有的切分边加入到优先队列中。同时不断地删除优先队列中连接两个生成树内顶点的边。



## 实现

我们先用visit()方法去访问一个顶点。这个方法会将这个顶点标记到最小生成树的顶点数组中，同时再将所有连接这个顶点并且另一个顶点不属于最小生成树的边加入到优先队列。

之后循环从优先队列中取出权重最小的边，如果这个边已经失效，则跳过循环，否则将这条边加入到最小生成树中，将连接这条边的不属于生成树的顶点加入到生成树，再用visit()访问这个顶点。每次visit()会再次加入横切边，得以维持循环继续进行。

## 运行时间

#### prim的延时实现

```
public lazyPrimMST{

}
```

