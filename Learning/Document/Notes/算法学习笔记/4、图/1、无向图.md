# 无向图

我们首先要学的这种图，由顶点（edge）和边（vertex）组成。我们用0 ~ V-1来表示有V个顶点的图的各个顶点。用V-W来表示连接V和W的边

这种图的定义是

定义：图是由一组顶点和一组能够将两个顶点相连的边组成

特殊的图。我们允许两种特殊情况

- 自环，即一连接一个顶点和它自身的的边

- 平行边，连接同一对顶点两条边叫平行边 

## 术语表

当两个顶点通过一条边相连的时候，我们称这两个顶点是相邻的。当一个边连接两个顶点，我们称这条边依附于这两个顶点。顶点的度数是依附于这个顶点的所有边的总数。子图是组成一幅图的所有边的子集（以及它们所依附的所有顶点）。

> 定义：在图中，路径是由边顺序相连的一系列顶点。简单路径是不包含重复顶点和边的路径。环是起点和终点相同的路径。简单环是不包含重复顶点和边的环（除了起点和终点相同）。路径或环的长度为其所包含的边的总数。

 

大多数情况下，我们说的路径都是简单路径，并且省略简单二字。我们谈的环都是简单环，并省略简单二字。当我们允许重复顶点或边时，我们谈的是一般路径和一般环。如果一个顶点有一条路径到另一个顶点时，我们称这两个顶点是连通的。我们用u-v-w-r表示从顶点u到r的一条路径。用u-v-w-u表示从顶点u到u止的一个环。

> 定义：如果一幅图的任意一个顶点都存在一条路径到另一个任意顶点。我们称这是一幅连通图。如果一幅非连通图由多个连通子图组成，我们称这图为极大连通子图

直观上说，如果顶点是物理存在的对象例如念珠或绳结，而边也是物理存在的对象，那么我们提起任意一结点，连通图会保持一个整体，而非连通图会分为若干个部分。一般来说，要处理一幅图，就要一个个处理它的连接分量（子图）。

无环图是一种不包含环的图。我们要学习的几种算法就是找出图中的满足一定条件的无环子图

> 定义：树是一幅无环连通图，互不连通的树称为森林。连通图的生成树是它的子图，并且是一棵树，而且含有连通图的所有顶点。图的生成树森林是它的所有连通子图的生成树集合。

**树的定义**：当且仅当一幅含有V个顶点的图G满足以下5个条件之一时，它就是一棵树

- G有V-1条边且不含有环

- G有V-1条边且时连通的

- V是连通的，但删除任意一条边都使它不再连通

- G是无环图，但添加任意一条边都会产生一条环

- G的任意一条顶点之间仅存在一条简单路径

图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图种，被连接的顶点对很少。而在稠密图种，只有少部分顶点对之间没有边连接

二分图是一种能够将所有结点分为两部分的图。其中图的每条边所连接的两个顶点都分属于不同的部分。

## 表示无向图的数据类型

#### 无向图的API

|           |                                   |
| --------- | --------------------------------- |
| Graph()   | 创建一个含有V个顶点但不含有边的图 |
| Graph()   | 从标准输入流读取一幅图            |
| V()       | 顶点数                            |
| E()       | 边数                              |
| addEdge() | 添加一条边v-w                     |
| adj       | 和v相邻的所有顶点                 |
| toString  | 对象的字符串表示                  |

#### 图的几种表示方法

我们需要某种数据结构来实现这份API，需要满足这些要求

-   必须为各种类型的图预留足够的空间

-   必须足够快

可以有三种方式

-   邻接矩阵

-   边的数组

-   邻接表数组。
  -   使用一个以顶点为索引的数组，其中的每个元素保存这个顶点的所有的相邻顶点。

#### 邻接表的数据结构

非稠密图的标准表示为邻接表的数据结构。它将每个顶点放到一个数组的索引中，每个元素的的值是一个放入所有该顶点的相邻顶点的链表。

###### Graph数据类型

确定顶点数目之后创建相同数目的空的链表，读取一条边的时候把两个顶点的数据放到相应的邻接表中。

class Graph{}

这份算法实现了一个由顶点为索引的链表数组。每条边都会出现两次。例如添加一条边v-w，会将w添加到索引为顶点v所指向的链表中，同时也会将v添加到索引为顶点w所指向的链表中。

#### 图的处理算法的设计模式

###### 图算法的API

| Search(Graph G, int s) | 找到所有和起点s连通的顶点 |
| ---------------------- | ------------------------- |
| marked(int v)          | v和s是连通的吗            |
| count()                | 与s连通的所有顶点总数     |

`class TestSearch{}`

这个用例会读取一幅图，并且查找出图中某个顶点的所有连通顶点的数量，同时判断这幅图是不是连通的。

在之前的union-find实现了这种API，他会把图中的所有边进行一次union(),并使用connected()来实现marked()。但我们可以用更加简单高效的方法—深度优先搜索

## 深度优先搜索

如果我们想要得到图的一些简单性质（例如检查顶点的度数），我们只需要检查图的每一条边即可。但很多性质都跟图的路径有关，一种简单的策略是沿着边从一个顶点到另一个顶点。

深度优先搜索就是从起点开始一个访问从未访问过的邻接顶点，然后将这个顶点标记未已访问，直到遇到死路开始回退到上一个顶点，再去访问这个顶点的未标记过的邻接顶点。直到访问完所有顶点。

如果将访问的路径放到一个数组里，就可以得到从起点到所有连通的顶点的路径。例如从v访问w记为edgeTo[w] = v。

通常可以用来找到从起点s到所有连通顶点的一条路径。

#### 走迷宫

有一种古老的探索迷宫的方法叫做Tremaux搜索

- 选择一条没有标记过的通路，在走过的路上铺上绳子

- 标记所有你第一次走过的路

- 如果走到了死路就沿着绳子回退上一个路口

- 如果回退到的路口没有未标记的通道，继续回到上一个路口。

绳子保证了可以回退，而标记可以保证不会重复走同一条道路。要知道是否完全探索了整个迷宫需要更复杂的证明。

#### 热身

搜索连通图的经典递归算法（遍历所有顶点和边）和tremaux类似，要搜索一个图，只需要用一个递归方法遍历所有顶点，在访问一个顶点的时候要：

- 将这个点标记未已访问

- 继续递归访问这个顶点的所有未被标记的邻居顶点。

如果图是连通的，每个邻接表的元素都会被发访问到

#### 单向通道

深度优先算法的代码调用和返回与Tremaux的绳子作用相同，函数调用相当于向前走铺绳子。return相当于迷宫走到死路开始返回。	

#### 跟踪深度优先搜索

算法遍历边和访问顶点的顺序和图的表示有关，每条边都会访问两次，在第二次会发现顶点已经访问过。

#### 深度优先所有的详细轨迹

对于一个起点为0的搜索，查找开始于构造函数调用递归的dfs()来标记和访问顶点0，后续会递归的访问所有邻接表中的未被标记的顶点。

###### 这种简单的递归模式只是一个开始

深度优先搜索能处理很多关于图的任务

###### 连通性

给定的两个顶点是否连通

图中有多少个连通子图

###### 单点路径

给定一幅图和一个顶点s，是否存在一个由s到v的路径。

## 寻找路径

单点路径问题在图的计算中十分重要，根据图的设计模式，将使用如下API  

| Paths(Graph G, int s) | 以s为起点的所有路径            |
| --------------------- | ------------------------------ |
| hasPathTo(int V)      | 是否存在从s到v的路径           |
| pathTo(int v)         | 从s到v的路径，没有则返回null。 |

#### 实现

算法4.1基于深度优先搜索实现了paths，扩展了DepthFirstSearch。添加了一个变量edgeTo[]数组来代替tremaux搜索中绳子的作用。这个算法回去遍历所有路径，并且在经过v-w边的时候设置edgeTo[w] = v。这样就能知道从起点s到顶点w的路径上最后一个顶点是v。用同样的方法递归可以得到整个路径。

```
class DepthFirstPaths
{

}
```

在深度优先搜索中，每个顶点只会被访问一次。所以edgeTo数组的元素不会被覆盖。

这个Graph用例使用深度优先搜索找到了从起点到所有连通顶点的路径，用edgeTo数组保存第一次访问某顶点的路径，得到的是一个用父链接表示的以起点s为根结点的且含有所有和s连通的顶点的树。

#### 详细轨迹

用例会从起点s开始访问它的一个未被标记的邻接顶点，然后再将这个顶点标记为已访问。用例会递归地去访问当前顶点的邻接顶点。如果当前顶点没有未被标记的顶点，就会回退到上一个顶点访问其它的未标记邻接顶点。每一次访问邻接顶点都会在edgeTo数组中记录这一次访问的路径。例如访问v-w，会记为edgeTo[w] =v。通过这个数组可以得到从起点到所有连通顶点的路径。

## 广度优先搜索

深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示和递归调用的性质。我们自然地还会对如下问题感兴趣

​    单点最短路径。从起点s到给定的顶点v是否存在一条路径。如果有，找到最短的路径。

解决这个问题的算法叫广度优先搜索。深度优先搜索对解决这个问题没什么帮助。广度优先搜索的方法正是为了这个目标。要找到起点s到顶点v的最短路径，先从距离起点s为1的顶点中找v，如果找不到就从距离为2的顶点找。每次都去查找更远的顶点是否是目标顶点v。

相比较而言，深度优先搜索就像是一个人拿着绳子从一个方向探索到死路才回退，继续探索其他方向。而广度优先搜索就像是探索人员遇到多个探索方向就开始分裂，每个人探索一个方向。每个人有自己的绳子。如果两个人从交叉路口相遇就开始合并，并且使用先到达的人的绳子。

在程序中，搜索一幅图会遇到有多条边待搜索的情况，我们会选择其中一条并留待以后搜索。在深度优先搜索会有一个下压栈（由系统管理来实现递归搜索方法）。使用后进先出的规则来描述压栈和走迷宫时先探索相邻的的通道类似。深度优先搜索会先探索最晚遇到的通道。而广度优先搜索需要按照与起点的距离来依次搜索，需要在待搜索通道中先搜索最早遇到的通道，而这只需要用队列（FIFO，先进先出）来代替栈（LIFO，后进先出）即可

实现

```
class DreadthFirstPaths{
}
```

以下算法实现了广度优先搜索，它使用了一个列队来保存所有已被访问但其邻接顶点还未被遍历的顶点。首先将起点加入到队列中，然后重复以下步骤直到队列为空

- 从队列中取出一个顶点并标记它

- 访问这个顶点的所有未被标记的邻接顶点且加入队列，并标记这些邻接顶点

- 它显式地使用了一个队列。和深度优先搜索一样，得到的edgeTo数组是以父链接为表示的树。

## 连通分量

深度优先搜索的下一个直接应用就是找出一幅图的所有连通分量，它能够将所有顶点切分为等价类（连通分量）。对这个任务有以下API

| class CC                |                       |
| ----------------------- | --------------------- |
| CC(Graph G)             | 预处理构造函数        |
| connected(int v, int w) | v和w连通吗            |
| count()                 | 连通分量总数          |
| id(int v)               | v所在连通分量的标识符 |

用例可以用id（）方法将连通分量用数组保存，然后用每个子图的标识符做数组的索引，然后将每个子图的顶点保存到顶点所在子图的标识符的索引所对应的数组中  

#### 实现

```
class CC{

}
```

这个算法基于深度优先搜索，用数组id来保存每个顶点所在连通分量的标识。

#### union-find算法

CC中基于深度优先搜索来解决连通性问题的算法和union-find相比。union-find是一种动态算法，而深度优先算法需要先读取一幅图进行预处理。如果只需要查询连通性或者有大量的连通性查询和插入混合的场景更适合union-find，而深度优先搜索更适合实现图的抽象数据类型，因为可以有效利用已有的数据结构。

深度优先搜索还可以解决以下两个问题

- 检测环：给定的图是无环图吗

- 双色问题：用两种颜色给所有顶点着色，能够让任意一条边的两个端点的颜色都不相同啊。这个问题也可以等价为：这是一幅二分图吗？
- G是无环图图？（假设不存在自环或平行边）    class Cycle{}
- G是二分图吗？（双色问题）                class TwoColor{}

二分图是图论中的一种特殊模型，能够将图中的所有顶点分为两个互不相交的子集，两个子集之间的顶点可以有边连接，但同一个子集内部的顶点之间不能有边连接。

## 符号表

在典型应用中，图是由网页或者文件定义的。顶点不是整数而是字符串。为适应这些特点，我们定义以下输入格式

-   顶点名是字符串

-   用指定的分隔符隔开各个顶点。

-   每一行都是一组边的集合。每一条边都连接这一行第一个名称所表示的顶点和这一行其他名词所表示的顶点

-   图的顶点数和边数是隐式的。

在movies.txt中，3.5节介绍的互联网电影数据库。根据上述定义，可以将每行的第一个顶点设置为电影名字，然后本行的其他顶点设置为本电影的参演演员，并将电影名和演员名连接起来。注意这个图是二分图——电影之间和演员之间没有连接。

#### API

在API定义的Graph用例可以直接使用已有的图算法来处理这种文件定义的图

| class SymbolGraph                         |                                                     |
| ----------------------------------------- | --------------------------------------------------- |
| SymbolGraph(String filename,String delim) | 根据filename指定文件构造图，并用delim来分割顶点名。 |
| contains(String key)                      | key是一个顶点吗                                     |
| index(String key)                         | key的索引                                           |
| name(int v)                               | 索引v的顶点名                                       |
| G()                                       | 隐藏的Graph对象                                     |

#### 测试用例

下面的测试用例可以从文件中读取并构建一幅图。对于movies.txt，我们可以通过电影名来找到所有的参演演员，这只不过是照搬文件行里的数据，但是我们可以通过演员名来找他参演的所有电影，这就是反向索引，二分图会自动完成反向索引。

这种方法适用于我们所有的图算法，我们可以用index（）将顶点名转化为索引，然后存储在图中，也可以用keys（）来将索引转化为顶点名以方便实际应用中使用。

#### 实现

SymbolGraph的实现使用三种数据结构。

-   一个符号表st，键的类型为String（顶点名），值的类型为int（索引）

-   一个数组keys[]，键的类型为int（索引），值的类型为string（顶点名），保存每个顶点索引所对应的顶点名

-   一个Graph对象G，用索来引用图中顶点。

#### 间隔的度数

图处理的一个经典问题就是，找到一个社交网络两个人间隔的度数。用一个 Kevin Bacon 的游戏来说明这个概念，我们为图中每个演员赋值一个Kevin Bacon数，Bacon本人的Kevin Bacon数为0，所有和Kevin Bacon出演过同一部电影的演员赋值为1，所有和Kevin Bacon数为1的演员出演过同一部电影的演员赋值为2，以此类推。但是在整个网络中一个演员的Kevin Bacon数取决于最下的Kevin Bacon数。

```
public class DegreesOfSeparation{

}
```



##  总结

本节中，我们介绍了几个基本概念

- ​    图的术语

- ​    一种图的表示方法，能够处理大型而稀疏的图

- ​    和图处理相关的类的设计模式，其实现算法通过构造函数对图进行预处理，来构造相关的数据结构来支持对图的查询。

- ​    深度优先搜索和广度优先搜索

- ​    支持使用符号作为图的顶点名的类

在之后处理其他的图的类型和更加复杂的图问题问题的时候，我们会用到这些代码的变种。

本节中得到解决的无向图处理问题

| 单点连通性   | DepthFirstSearch  |
| ------------ | ----------------- |
| 单点路径     | DepthFirstPaths   |
| 单点最短路径 | BreadthFirstPaths |
| 连通性       | CC                |
| 检测环       | Cycle             |
| 双色问题     | TwoColor          |

