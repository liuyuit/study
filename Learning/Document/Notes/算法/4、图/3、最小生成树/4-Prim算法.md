# Prim算法

Prim算法的每一步都会为一棵生长中的树添加一条边。

> 命题L：Prim算法能够得到任意无向加权图的最小生成树
>
> 证明：

## 数据结构

我们需要用以下方法来表示边、顶点、横切边

- 顶点：使用一个由顶点索引的数组marked[]，如果顶点v在树中，那么marked[v] == true;
- 边。可以有以下两种选择：一条mst队列，来保存所有生成树的边。或者一个由顶点索引的edgeTo[]数组，edgeTo[v]为将v连接到树种的edge对象。
- 横切边：使用一条优先队列，来根据权重比较所有边。

## 维护横切边的集合

算法构造最小生成树的过程如下

- 将任意初始顶点加入到最小生成树中。
- 将初始顶点的所有邻接边加入到优先队列中
- 将最小横切边所连的顶点加入到最小生成树中
- 将新加入顶点的所有邻接边加入到优先队列中
- 将优先队列中连接两个在生成树顶点的边删除掉，因为它们已经不是横切边

这种算法的关键在于将最小生成树中的所有顶点看作一个集合，将所有不在生成树中顶点看作切分的另一个集合，把所有的切分边加入到优先队列中。同时不断地删除优先队列中连接两个生成树内顶点的边。

## 实现

我们先用visit()方法去访问一个顶点。这个方法会将这个顶点标记到最小生成树的顶点数组中，同时再将所有连接这个顶点并且另一个顶点不属于最小生成树的边加入到优先队列。

之后循环从优先队列中取出权重最小的边，如果这个边已经失效，则跳过循环，否则将这条边加入到最小生成树中，将连接这条边的不属于生成树的顶点加入到生成树，再用visit()访问这个顶点。

## 