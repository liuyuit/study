# 无向图

我们首先要学的这种图，由顶点（edge）和边（vertex）组成。我们用0 ~ V-1来表示有V个顶点的图的各个顶点。用V-W来表示连接V和W的边

这种图的定义是

定义：图是由一组顶点和一组能够将两个顶点相连的边组成

特殊的图。我们允许两种特殊情况

- 自环，即一连接一个顶点和它自身的的边

- 平行边，连接同一对顶点两条边叫平行边 

## 术语表

当两个顶点通过一条边相连的时候，我们称这两个顶点是相邻的。当一个边连接两个顶点，我们称这条边依附于这两个顶点。顶点的度数是依附于这个顶点的所有边的总数。子图是组成一幅图的所有边的子集（以及它们所依附的所有顶点）。

> 定义：在图中，路径是由边顺序相连的一系列顶点。简单路径是不包含重复顶点和边的路径。环是起点和终点相同的路径。简单环是不包含重复顶点和边的环（除了起点和终点相同）。路径或环的长度为其所包含的边的总数。

 

大多数情况下，我们说的路径都是简单路径，并且省略简单二字。我们谈的环都是简单环，并省略简单二字。当我们允许重复顶点或边时，我们谈的是一般路径和一般环。如果一个顶点有一条路径到另一个顶点时，我们称这两个顶点是连通的。我们用u-v-w-r表示从顶点u到r的一条路径。用u-v-w-u表示从顶点u到u止的一个环。

> 定义：如果一幅图的任意一个顶点都存在一条路径到另一个任意顶点。我们称这是一幅连通图。如果一幅非连通图由多个连通子图组成，我们称这图为极大连通子图

直观上说，如果顶点是物理存在的对象例如念珠或绳结，而边也是物理存在的对象，那么我们提起任意一结点，连通图会保持一个整体，而非连通图会分为若干个部分。一般来说，要处理一幅图，就要一个个处理它的连接分量（子图）。

无环图是一种不包含环的图。我们要学习的几种算法就是找出图中的满足一定条件的无环子图

> 定义：树是一幅无环连通图，互不连通的树称为森林。连通图的生成树是它的子图，并且是一棵树，而且含有连通图的所有顶点。图的生成树森林是它的所有连通子图的生成树集合。

当且仅当一幅含有V个顶点的图G满足以下5个条件之一时，它就是一棵树

- G有V-1条边且不含有环

- G有V-1条边且时连通的

- V是连通的，但删除任意一条边都使它不再连通

- G是无环图，但添加任意一条边都会产生一条环

- G的任意一条顶点之间仅存在一条简单路径

图的密度是指已经连接的顶点对占所有可能被连接的顶点对的比例。在稀疏图种，被连接的顶点对很少。而在稠密图种，只有少部分顶点对之间没有边连接

二分图是一种能够将所有结点分为两部分的图。其中图的每条边所连接的两个顶点都分属于不同的部分。

## 表示无向图的数据类型

#### 无向图的API

|           |                                   |
| --------- | --------------------------------- |
| Graph()   | 创建一个含有V个顶点但不含有边的图 |
| Graph()   | 从标准输入流读取一幅图            |
| V()       | 顶点数                            |
| E()       | 边数                              |
| addEdge() | 添加一条边v-w                     |
| adj       | 和v相邻的所有顶点                 |
| toString  | 对象的字符串表示                  |

#### 图的几种表示方法

我们需要某种数据结构来实现这份API，需要满足这些要求

-   必须为各种类型的图预留足够的空间

-   必须足够快

可以有三种方式

-   邻接矩阵

-   边的数组

-   邻接表数组。
  -   使用一个以顶点为索引的数组，其中的每个元素保存这个顶点的所有的相邻顶点。

#### 邻接表的数据结构

非稠密图的标准表示为邻接表的数据结构。它将每个顶点放到一个数组的索引中，每个元素的的值是一个放入所有该顶点的相邻顶点的链表。

###### Graph数据类型

确定顶点数目之后创建相同数目的空的链表，读取一条边的时候把两个顶点的数据放到相应的邻接表中。

class Graph{}

这份算法实现了一个由顶点为索引的链表数组。每条边都会出现两次。例如添加一条边v-w，会将w添加到索引为顶点v所指向的链表中，同时也会将v添加到索引为顶点w所指向的链表中。

#### 图的处理算法的设计模式

###### 图算法的API

| Search(Graph G, int s) | 找到所有和起点s连通的顶点 |
| ---------------------- | ------------------------- |
| marked(int v)          | v和s是连通的吗            |
| count()                | 与s连通的所有顶点总数     |

`class TestSearch{}`

这个用例会读取一幅图，并且查找出图中某个顶点的所有连通顶点的数量，同时判断这幅图是不是连通的。

在之前的union-find实现了这种API，他会把图中的所有边进行一次union(),并使用connected()来实现marked()。但我们可以用更加简单高效的方法—深度优先搜索

## 深度优先搜索

如果我们想要得到图的一些简单性质（例如检查顶点的度数），我们只需要检查图的每一条边即可。但很多性质都跟图的路径有关，一种简单的策略是沿着边从一个顶点到另一个顶点。

深度优先搜索就是从起点开始一个访问从未访问过的邻接顶点，然后将这个顶点标记未已访问，直到遇到死路开始回退到上一个顶点，再去访问这个顶点的未标记过的邻接顶点。直到访问完所有顶点。

如果将访问的路径放到一个数组里，就可以得到从起点到所有连通的顶点的路径。例如从v访问w记为edgeTo[w] = v。

通常可以用来找到从起点s到所有连通顶点的一条路径。

#### 走迷宫

有一种古老的探索迷宫的方法叫做Tremaux搜索

- 选择一条没有标记过的通路，在走过的路上铺上绳子

- 标记所有你第一次走过的路

- 如果走到了死路就沿着绳子回退上一个路口

- 如果回退到的路口没有未标记的通道，继续回到上一个路口。

绳子保证了可以回退，而标记可以保证不会重复走同一条道路。要知道是否完全探索了整个迷宫需要更复杂的证明。

#### 热身

搜索连通图的经典递归算法（遍历所有顶点和边）和tremaux类似，要搜索一个图，只需要用一个递归方法遍历所有顶点，在访问一个顶点的时候要：

- 将这个点标记未已访问

- 继续递归访问这个顶点的所有未被标记的邻居顶点。

如果图是连通的，每个邻接表的元素都会被发访问到

#### 单向通道

深度优先算法的代码调用和返回与Tremaux的绳子作用相同，函数调用相当于向前走铺绳子。return相当于迷宫走到死路开始返回。	

#### 跟踪深度优先搜索

算法遍历边和访问顶点的顺序和图的表示有关，每条边都会访问两次，在第二次会发现顶点已经访问过。

#### 深度优先所有的详细轨迹

对于一个起点为0的搜索，查找开始于构造函数调用递归的dfs()来标记和访问顶点0，后续会递归的访问所有邻接表中的未被标记的顶点。

###### 这种简单的递归模式只是一个开始

深度优先搜索能处理很多关于图的任务

###### 连通性

给定的两个顶点是否连通

图中有多少个连通子图

###### 单点路径

给定一幅图和一个顶点s，是否存在一个由s到v的路径。

## 寻找路径

​         单点路径问题在图的计算中十分重要，根据图的设计模式，将使用如下API  

|      |      |
| ---- | ---- |
|      |      |
|      |      |



## 广度优先搜索

## 连通分量

## 符号表

##  总结