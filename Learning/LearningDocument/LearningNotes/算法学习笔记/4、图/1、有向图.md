# 有向图

在有向图，边是单向的：每条边所连接的两个顶点是一个有序对，他们的邻接性是单向的

实际生活的典型有向图  

| 应用   | 顶点 | 边       |
| ------ | ---- | -------- |
| 食物链 | 物种 | 捕食关系 |
| 程序   | 模块 | 外部引用 |

## 术语

有向图和无向图的定义只有微小的差异。

> 定义：有向图是由一组顶点和一组有方向的边组成，每一条边连接一对有序的顶点。

我们成一条有向边由第一个顶点指出并指向第二个顶点。我们称一个顶点的出度为由该顶点指出的边的总数。一个顶点的入度为指向该顶点的边的总数。一条有向边的第一个顶点为边的头，被指向的第二个顶点为它的尾。将有向边画为由头指向尾的箭头。用v-》w表示由v指向w的一条边。

> 定义：在一幅有向图，有向路径由一系列顶点组成。对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。有向环为一条至少含有一条边且起点和终点相同的有向路径。简单有向环是一条不含有重复顶点（除了起点和终点必须仙童）和边的环。路径或环的长度即为其中所包含的边数。

当存在从v到w的路径时，我们称顶点w能够由顶点v到达，我们约定任何顶点v都能够由它自己到达。由于边是单向的，所以即使w能够由v到达，v也不一定能够由w到达。

你需要能够区分无向图的连通性和有向图的可达性的区别。

## 有向图的数据类型

以下有向图的api和Digraph类和无向图在本质上是相同的

| Digraph(int v)          | 创建一幅有v个顶点但没有边的有向图 |
| ----------------------- | --------------------------------- |
| Digraph(In in)          | 从输入流中创建一幅有向图          |
| v（）                   | 顶点数                            |
| E（）                   | 边数                              |
| addEdge（int v, int w） | 生成一条边v->w                    |
| adj（int v）            | 返回所有从顶点v指出的边           |
| reverse（）             | 该图的反向图                      |
| toString（）            | 对象的字符串表示                  |

#### 有向图的表示

我们使用邻接表来表示一个有向图，v->w表示v的邻接链表中包含一个w顶点。每条边只会出现一次。

#### 输入格式

读取有向图的构造函数和无向图的代码是一样的，但所有边都是有向边，一对顶点v、w，表示边v-》w。   

#### 有向图取反

Digraph的API中还添加了一个reverse()方法。这将返回图的一个副本，副本中的所有边都是反向的。这个在取出指向顶点的所有邻接顶点时很有用。因为原本的adf（）给出的是顶点指向的所有邻接顶点。

#### 顶点的符号名

允许顶点名使用符号也非常简单，实现类似于SymbolGraph的SymbolDigraph只需要将Graph改为Digraph即可。

```
class Digraph{

}
```



## 有向图的可达性

4.1.3.2节中的DepthFirstSearch可以解决无向图的单点连通性问题。使用完全相同的代码，将其中的Graph替换成Digraph，也可以解决类似的问题

单点可达性给定一幅图和一个顶点，回答“是否存在一条从顶点s到给定顶点v的有向路径”。

DirectedDFS类将DepthFirstSearch稍加修改

| DirectedDFS（Digraph G， int s）            | 在G中找到从s可达的所有顶点                   |
| ------------------------------------------- | -------------------------------------------- |
| DirectedDFS（Digraph G， Iterable sources） | 在G中找到从sources中的所有顶点可达的所有顶点 |
| marked（int v）                             | v是可达的吗                                  |

在添加了一个接受多个顶点的构造函数之后，这份用例可以解决一个更加一般性的问题。

多点可达性：给定一幅图和顶点的集合，回答“是否存在一条从集合中的任意顶点达到给定顶点v的有向路径”。

```
class DirectedDFS{

}
```

用用来判断从给定的一个或一组顶点能到达其他哪些顶点。

#### 标记-清除的垃圾收集

多点可达性的一个典型应用就是典型的内存管理，包括很多java的实现。在一幅有向图中，一个顶点表示一个对象。而一条边则表示对一个对象的引用。在程序执行的任何时候都有某些对象是可以被直接访问的。而不能通过这些对象访问到的所有对象都应该被回收以便释放内存。标记-清楚回收策略会为每一个对象保留一个为做垃圾回收之用，它会周期性的运行一个类似于DerectedDFS的有线图可达性算法来标记所有可被访问的对象。而没有被标记的对象则会被回收。

#### 有向图的寻路

DepthFirstPaths(4.1.4.1)和BreadthFirstPaths也都是有向图中的重要算法。同样的代码和API（仅将Graph替换成Digraph）也能高效地解决以下问题：

单点有向路径：给定一幅有向图和一个起点s，从起点s到给定目的顶点v是否存在一个有向路径？如果有，则找出它。

单点有向最短路径： 给定一幅有向图和一个顶点s，从起点s到给定目的顶点v是否存在一条有向路径？如果有，找出其中最短的那条（所含边数最少的）。

## 环和无向图

从原则上来说，一幅图可能含有大量的环。但实际上我们的应用只会关注其中的一小部分，或者只想知道有没有有向环。

#### 调度问题

#### 

## 有向图的强连通性













