# 散列表

如果所有的键都是小整数，那么使用数组将键作为索引。将值存储在数组对应索引所指向的值中。

使用散列的查找算法分为两步。第一步是将键通过散列算法转换为相应的索引。在数组对应索引中存储键和值。但是有可能存在不同的键却有相同的散列值。因此第二步就是处理碰撞冲突。有两种方法可以解决：拉链法，线性探测法。

## 散列函数

散列函数会将键转化为数组的索引，如果我们有一个能保存M个键值对的数组，我们的散列函数就需要能够将任意键转化为数组范围内的索引（【0，M-1】范围内的整数）。

散列函数与键的类型有关。比如键是整数直接用键进行计算即可。如果键是字符串，就需要先将字符串转化为数字。如果键包含多个部分，比如邮件地址，我们就需要将多个部分结合起来。

#### 典型的例子

假设键是美国的社保号，它由三部分组成，比如123-456-789。第一部分是颁发的地区，其他部分是身份信息。假设我们的应用程序只需要处理几百个键值对。我们可以使用一个M=1000的数组。一种实现方法是直接使用第三部分的数组作为索引，因为它们的重复率更低。但更好的方法是将三个部分的数组转化为一个整数。

#### 正整数

将正整数散列的最常用方法是除留余数法，对大小为M的数组，正整数k的散列值就是K除以M的余数。这种方式可以将任意整数k散列到【0，M-1】。但如果M不是素数，可能无法利用到k的所有位，如果k是十进制树并且M=10的n次方，那么除留余数法只能利用到k的后n位数字。所以M为素数（2的幂除外）会更好

#### 浮点数

如果键是0到1之间的实数，我们将键乘以M再四舍五入可以得到0到M-1之间的整数。但这种方法的缺陷在于键的高位起的作用更大，最低位对结果没有影响。一种解决方法就是把k转化成二进制数再对M做除留余数法。

#### 字符串

除留余数法也可以用来处理字符串，只要把它当作一个大整数即可

```
int hash = 0;
for(int I = 0; i < s.lenth(); i++){
	hash = (R * hash + s.charAt(i)) % M
}
```

Java的charAr（）方法是返回字符串某一位字符的整数值，如果R大于所有字符的整数值，这段代码就代表把每个字符当作N位的R进制树。再对M做除留余数法

#### 组合键

如果键的类型含有多个整型变量，我们可以和string类型一样将它们混合起来。例如我们查找的键的类型是Date，其中含有多个整型：day、month、year。可以用以下方法来计算散列值  

```
int hash = (((day * R + month) % M) * R + year) % M;
```

只要R足够小不造成溢出，我们可以得到0到M-1的散列值，在这种情况下，我们选择一个较小的M比如31就可以省略括号内的%M计算

#### java的约定

每个数据类型都需要散列函数，所有每种数据类型都有hashCode()方法，并且需要和equals()一致，就是说如果a.equals(b)返回true，那么a和b的散列值也要相等，反过来散列值相等a和b却不一定相等，还要通过equals来确定。

#### 将hashCode()的返回值转化数组的索引

我们需要的是数组的索引而不是32位的散列值，我们可以通过hashCode方法和除留余数法来得到一个数组索引  

```
function hash(key k){
	int hash = (k.hashCode() & 0x7fffffff) % M;
	return hash;
}
```

这段代码会把符号位屏蔽（把32位整数转化为31位的非负整数），然后对M取余，我们一般会将数组的大小M取为素数，以充分利用原散列值的所有位。

#### 自定义hashCode方法

散列表的用例希望能够将键平均的散列为任意的32位整数也就是说，对于任意对象x，都可以调用x.hashCode()并有均等的机会得到一个随机的2的32次方整数。在java中每一种数据类型都实现了hashCode()方法，因此对于对象的一个简单的做法是将每一个变量调用hashCode()方法，将返回值转化为32位整数并计算得到散列值。如transaction所示  

```
public class transaction{
	String who;
	Date when;
	double amount;
	
	public int hashCode(){
		int hash = 17;
		hash = hash * 31 + who.hashCode();
		hash = hash * 31 + when.hashCode();
		hash = hash * 31 + ((double)amount).hashCode();
		return hash;
	}
} 
```

#### 软缓存

如果散列值的计算很耗时，我们可以把键的散列值缓存起来。第一次调用hashCode（）方法我们需要进行计算，然后将返回值保存到键的hash变量中，之后再调用就直接从hash变量中取值。

一个优秀的hash算法需要满足以下三个条件

###### 一致性

相同的键必然返回相等的散列值

###### 高效性

计算简便快速  

###### 均匀性

有均等的机会得到每一个可能的散列值

均匀的散列所有键

## 基于拉链法的散列表

一个散列函数可以把键转化为数组索引，第二步是处理冲突，也就是解决多个键的散列值相同的情况。一种简单的方法是把数组的每个元素指向一条链表。把所有散列值为该元素索引的键值对放入该链表。

算法3.5   SeparateChainingHashST

#### 散列表的大小

在实现基于拉链法的散列表的目标是找到一个合适的数组大小M。要实现即不因M太大而浪费内存，也不因M太小而加大查找时间。一种方法是动态调整数组大小  

#### 删除操作

要删除一个键值对，先通过键找到相应的SequentialSearchST对象，再调用该对象的delete()方法。

#### 有序性相关的操作

散列表的目标就是将键值对散列到不同的位置，然后位置信息就丢失了。

## 基于线性探测法的散列表

实现散列表的另一种方式是用空元素代替链表，假设键值对个数为N，数组大小为M，使M>N，如果散列值在某个数组索引发生了碰撞，就将按照某个规则寻找下一个索引。基于这种思想的叫做开放寻址法。

查找下一个索引有可能出现下面三种情况

- 查到一个空元素（未命中）
- 查到一个元素，键相同（命中）
- 查到一个元素，键不同（继续查找）

最简单的实现就是线性探测法，如果在散列值在某个索引发生了碰撞，就将索引加1，如果索引值已经达到最大，就从头开始查找。因为M>N，所以总能找到一个空元素。

#### 删除操作

我们不能简单的把要删除的键设为null，因为这样会找不到下一个碰撞的键，我们应该把所有被删除键右侧的键重新插入一遍。

#### 箭簇

线性探测平均成本取决于元素在插入数组后聚集成的一组连续的条目。叫做键簇，也就是所有碰撞后形成的连续的不为空的元素。

#### 线性探测法的性能分析

## 调整数组大小

我们可以动态调整数组大小来保证表的使用率不超过1/2.

#### 拉链法

#### 均摊分析

## 内存使用