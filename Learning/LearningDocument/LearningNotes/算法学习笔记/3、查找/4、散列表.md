# 散列表

如果所有的键都是小整数，那么使用数组将键作为索引。将值存储在数组对应索引所指向的值中。

使用散列的查找算法分为两步。第一步是将键通过散列算法转换为相应的索引。在数组对应索引中存储键和值。但是有可能存在不同的键却有相同的散列值。因此第二步就是处理碰撞冲突。有两种方法可以解决：拉链法，线性探测法。

## 散列函数

散列函数会将键转化为数组的索引，如果我们有一个能保存M个键值对的数组，我们的散列函数就需要能够将任意键转化为数组范围内的索引（【0，M-1】范围内的整数）。

散列函数与键的类型有关。比如键是整数直接用键进行计算即可。如果键是字符串，就需要先将字符串转化为数字。如果键包含多个部分，比如邮件地址，我们就需要将多个部分结合起来。

#### 典型的例子

假设键是美国的社保号，它由三部分组成，比如123-456-789。第一部分是颁发的地区，其他部分是身份信息。假设我们的应用程序只需要处理几百个键值对。我们可以使用一个M=1000的数组。一种实现方法是直接使用第三部分的数组作为索引，因为它们的重复率更低。但更好的方法是将三个部分的数组转化为一个整数。

#### 正整数

将正整数散列的最常用方法是除留余数法，对大小为M的数组，正整数k的散列值就是K除以M的余数。这种方式可以将任意整数k散列到【0，M-1】。但如果M不是素数，可能无法利用到k的所有位，如果k是十进制树并且M=10的n次方，那么除留余数法只能利用到k的后n位数字。所以M为素数（2的幂除外）会更好

#### 浮点数

如果键是0到1之间的实数，我们将键乘以M再四舍五入可以得到0到M-1之间的整数。但这种方法的缺陷在于键的高位起的作用更大，最低位对结果没有影响。一种解决方法就是把k转化成二进制数再对M做除留余数法。

#### 字符串

除留余数法也可以用来处理字符串，只要把它当作一个大整数即可

```
int hash = 0;
for(int I = 0; i < s.lenth(); i++){
	hash = (R * hash + s.charAt(i)) % M
}
```

Java的charAr（）方法是返回字符串某一位字符的整数值，如果R大于所有字符的整数值，这段代码就代表把每个字符当作N位的R进制树。再对M做除留余数法

#### 组合键

如果键的类型含有多个整型变量，我们可以和string类型一样将它们混合起来。例如我们查找的键的类型是Date，其中含有多个整型：day、month、year。可以用以下方法来计算散列值  

```
int hash = (((day * R + month) % M) * R + year) % M;
```

只要R足够小不造成溢出，我们可以得到0到M-1的散列值，在这种情况下，我们选择一个较小的M比如31就可以省略括号内的%M计算

#### java的约定

每个数据类型都需要散列函数，所有每种数据类型都有hashCode()方法，并且需要和equals()一致，就是说如果a.equals(b)返回true，那么a和b的散列值也要相等，反过来散列值相等a和b却不一定相等，还要通过equals来确定。

#### 将hashCode()的返回值转化数组的索引

我们需要的是数组的索引而不是32位的散列值，我们可以通过hashCode方法和除留余数法来得到一个数组索引  

```
function hash(key k){
	int hash = (k.hashCode() & 0x7fffffff) % M;
	return hash;
}
```

这段代码会把符号位屏蔽（把32位整数转化为31位的非负整数），然后对M取余，我们一般会将数组的大小M取为素数，以充分利用原散列值的所有位。

#### 自定义hashCode方法

散列表的用例希望能够将键平均的散列为任意的32位整数也就是说，对于任意对象x，都可以调用x.hashCode()并有均等的机会得到一个随机的2的32次方整数。在java中每一种数据类型都实现了hashCode()方法，因此对于对象的一个简单的做法是将每一个变量调用hashCode()方法，将返回值转化为32位整数并计算得到散列值。如transaction所示  

```
public class transaction{
	String who;
	Date when;
	double amount;
	
	public int hashCode(){
		int hash = 17;
		hash = hash * 31 + who.hashCode();
		hash = hash * 31 + when.hashCode();
		hash = hash * 31 + ((double)amount).hashCode();
		return hash;
	}
} 
```

#### 软缓存

如果散列值的计算很耗时，我们可以把键的散列值缓存起来。第一次调用hashCode（）方法我们需要进行计算，然后将返回值保存到键的hash变量中，之后再调用就直接从hash变量中取值。

一个优秀的hash算法需要满足以下三个条件

###### 一致性

相同的键必然返回相等的散列值

###### 高效性

计算简便快速  

###### 均匀性

有均等的机会得到每一个可能的散列值

均匀的散列所有键

## 基于拉链法的散列表

一个散列函数可以把键转化为数组索引，第二步是处理冲突，也就是解决多个键的散列值相同的情况。一种简单的方法是把数组的每个元素指向一条链表。把所有散列值为该元素索引的键值对放入该链表。

算法3.5   SeparateChainingHashST

#### 散列表的大小

在实现基于拉链法的散列表的目标是找到一个合适的数组大小M。要实现即不因M太大而浪费内存，也不因M太小而加大查找时间。一种方法是动态调整数组大小  

#### 删除操作



#### 有序性相关的操作

## 基于线性探测法的散列表

## 调整数组大小

## 内存使用