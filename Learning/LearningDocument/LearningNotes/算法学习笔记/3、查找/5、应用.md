# 应用

符号表的应用非常广泛

## 我应该使用符号表的哪种实现

散列表的优势在于代码结构简单，查找时间最优，但是不支持顺序操作。二叉树的优势在于抽象结构简单。红黑树的优势在于最坏情况下查找最优，且支持多种操作。多数情况下的第一选择是散列表，除非其他操作更重要。

#### 原始数据类型

加入我们有一张符号表，整型的键对应浮点型的值。对于标准实现，我们会把键和值保存在Key和Value对象中。这会额外增加两个引用，在大型应用中会带来额外的开销。我们可以把它们保存到原始数据类型中。

#### 重复键

符号表的实现需要考虑重复键的可能，许多应用都希望能够为一个键保存多个值。符号表不允许多个键，用例只能自己保管多个键。

#### java标准库

在本书中用ST代表RedBlackBST,用HashST代表有序性操作无关紧要的LinearProbingdHashST。

## 集合的API

某些应用程序不需要对值进行操作，只需要插入键，并检测键是否存在。

#### 集合数据类型的一组API

###### SET

创建一个空的集合

###### add

将键加入到集合

###### contains

键key是否在集合中

###### isEmpty

集合是否为空

###### size

集合中键的数量

###### toString

对象的字符串表示

## dedup

过滤器的原型是是dedup，用于检测输入的键是否存在，如果存在则忽略它，否则将它加入到dedup中并打印。

#### 白名单和黑名单

过滤器的另一个经典应用是白名单和黑名单。白名单可以忽略不在白名单中的键，黑名单功能也类似。

## 字典类用例

符号表最简单的应用就是连续向符号表中put(),并进行get（）操作。

## 索引类用例

字典的主要特点是每个键都有一个关联的值，但有时候一个键可能关联多个值，这种情况下我们只需要用某种数据结构（例如queue）代替即可

#### 反向索引

在某些系统中一个键对应一个SET类型的值，而反向索引就是通过这个SET类型中的某个关键字来查找到对应的键。

## 稀疏向量

我们要考察的简单计算就是矩阵和向量的乘法。