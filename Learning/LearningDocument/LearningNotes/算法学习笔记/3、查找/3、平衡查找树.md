# 平衡查找树

> 二叉树可能退化成链表，所以需要平衡算法来防止退化

## 2-3查找树

为了保证查找的平衡性，我们需要更加灵活，因此我们允许一个结点保存多个结点。我们将标准二叉树的结点称之为2结点（含有一个键和两个链接），现在我们引入3结点，它含有两个键和三个链接，2结点和3结点的每个连接都对应着由结点的键分割的一个区间。

确切地说，2结点，含有一个键和两个链接，左链接指向小于根结点的键的子树，右链接指向大于根结点键的子树。

3结点，含有两个键和三个链接，左链接指向小于根结点的左键的子树，中链接指向位于根结点的左键和右键之间的子树。右链接指向大于右键的子树。

我们将指向一个空树的链接称之为空链接

一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。

## 红黑二叉查找树

红黑树使用由左斜的红链接相连的两个2-结点来表示3-结点。这样的话，红黑树即可以通过转换表示为2-3树，又是一个标准的二叉树。好处在于即可以使用标准二叉的简洁方法来实现各种操作，又可以用2-3树的分解4-结点的方式来进行插入以保持完美的黑链接平衡

#### 替换3-结点

红黑树的思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们用由一个红色左链接相连的两个2-结点表示一个3-结点。这中表示法的优点是我们可以用标准二叉树的get（）方法进行查找。对于任意的2-3树，我们只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树

#### 一种等价的定义

- 任何一个结点不可能与两个红链接相连
- 任何一个空链接到根结点之间的黑链接数相同。
- 红链接均为左链接

#### 一一对应

如果将所有的红链接放平的话，我们可以看到所有的空链接到根结点的距离相同。首先，我们可以将红黑树在二叉树和2-3树之间进行转换，如果我们将所有由左斜的红链接相连两个2-结点合并就变成了一个2-3树，反之如果将2-3树的所有3-结点表示为由左斜的红链接相连的两个2-结点，它就变成了一个标准二叉树。红黑树所有空链接到根结点之间的黑链接树相同，因为黑链接就是原本2-3树的普通链接。并且所有结点都不可能同时连接两个红链接。如果我们能够结合二叉树和2-3树的算法，我们就可以同时使用二叉树简洁的查找算法，和2-3树插入的完美平衡算法

#### 颜色表示

为了方便，因为每个结点都只会有一条指向自己的链接（由它的父结点指向它），我们将链接的颜色信息保存在这条链接指向的结点的color变量中，如果color的值为true则表示红色，如果为false则为黑色。为了代码简洁。我们将这两个值保存为常量RED和BLACK，我们用isRed()来判断一个结点和它的父结点之间的链接颜色。

#### 旋转

在我们实现的某些操作可能会出现红色的右链接或者连续的红链接，但在完成操作前我们会通过旋转来修复它。旋转操作会改变红链接的指向。例如我们有一条红色的右链接需要被转化为红色左链接，这个操作叫做左旋转。这个方法接受一个指向红黑树某个结点的链接，它会返回一个左链接是红色的根结点的链接。这个方法只是将一个较小值作根结点改为由一个较大值为根结点。实现右旋转和左旋转的逻辑完全相同。

#### 在旋转后重置父结点的链接

左旋转和右旋转都会返回一个链接，来重置父结点的相应链接。这个链接可能是红色也可能是黑色，这可能会产生两条连续的红链接，但我们的算法会使用继续用旋转来修正这种情况

在插入新的键我们可以用旋转来保证树的完美平衡性和有序性，下面我们需要保证红黑树的另外两条性质，不存在两条连续的红链接和不存在红色的右链接。

#### 向2-结点中插入新键

一棵只有一个键的红黑树只有一个2-结点，向它插入一个结点后，我们需要立即进行旋转操作。如果插入的新键小于根结点的键，我们会新增一个红色左链接指向的结点。如果插入的新键大于根结点的键，我们会新增一个红色右链接指向的结点，这时候我们就需要root=rotateLeft(root)来进行左旋转，使之变成一个由一个根节点和一个红色左链接指向的结点，并修正根结点的链接。两种情况都会得到一棵和单个3-结点等价的红黑，其中含有两个键，一个红色左链接，黑链接的高度为1。

#### 向树底部的2-结点插入新键

用和二叉查找树相同的方式向一棵红黑树插入一个新键会在树的底部新增一个结点（为了保证树的有序性）。然后将新结点用红链接向父结点相连，如果这个红链接是左链接，那么这就是一个3-结点。如果这个红链接是右链接，那么这个3-结点就是错误的，我们需要一次左旋转来修正它。

#### 向一颗双键树（即3-结点）插入一个新键

这种情况又可以分为三种子情况：新键小于树中的两个键，新键在树的两个键之间，新键大于树中的两个键。每种情况都会产生一个连接两个红链接的新树。而我们的目标就是修复它

- 新键大于树中的两个键

  这是最简单的情况，此时树是平衡的，中键作为根结点，它有两个红色链接分别指向较大的结点和较小的结点。我们只需要将两个红链接变为黑链接即可，就类似于将一个4-结点分解为3个2-结点。，此时新树任然是完美平衡的，并且黑链接的高度+1。其他两种情况最终也会转化为这种情况

- 新键小于原树中的两个键

  此时原树中的较小键会有一个红色左链接指向新键，此时产生了两条连续的红色左链接，我们只需要将上层的红色左链接进行右旋转就变成了第一种情况（中键为根结点并且有两条红色链接指向其他两个结点）。

- 新键介于原树中两个键之间

  此时原树中较小键会有一条红色右链接指向新键。此时我们只需要将下层的红色右链接进行左旋转就变成了第二种情况（两条连续的红色左连接）

总之我们通过0次、1次、2次旋转得到了预期的结果  

#### 颜色转换

我们用一个专门的方法flipColors()来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红转黑之外，还将父结点的颜色由黑转红。这个操作是局部变换，不会影响到全局的黑色平衡性。

#### 根结点总是黑色

颜色转换会使根结点变为红色。红色的根结点说根结点是一个3-结点的一部分。但实际上，我们每次插入都会把根节点变为黑色。每次把根节点变为黑色时黑链接的高度就会+1  

#### 向树底部的3-结点插入新键

现在假设我们向一个树底部的3-结点下插入一个新键。这时候我们之前提到的3中情况都会出现，可能向3-结点中插入一个右链接（只需要进行颜色转换即可），也可能向3-结点中插入一个左链接（只需将上层链接进行一次右旋，再进行颜色转换），也可能向3-结点中插入一个中链接（先将下层链接进行左旋，再将上层链接进行右旋，最后进行颜色转换）。颜色转换后根结点会变成红色，这相当于将一个送入父结点，相当于在父结点中插入一个新键，我们继续用相同的方法解决这个问题

#### 将红链接在树中传递

2-3树的插入算法需要我们分解3-结点，将中键送入到父结点中，直到遇到一个2-结点或根结点。我们考虑的所有情况都是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。这对于父结点来说处理一个这样的红色结点和在底部结点插入新的红色结点是一样的，即继续把红色结点转移到中结点中去。在红黑树中实现2-3树的插入算法的关键操作所需的步骤：要在一个3-结点中插入新键，先创造一个临时的3-结点，再将其分解，由中结点将红色链接继续向上传递给它的父结点。重复这个过程，我们就能将红链接继续向上传递，直至遇到一个2-结点或 根结点。

我们只要谨慎地使用左旋转、右旋转、颜色转换，就可以实现和2-3树一一对应的插入操作。在沿着插入结点到根结点之间的所有结点顺序执行以下操作，就可以完成插入操作

- 如果左子结点是黑色的，而右子结点是红色的，对右链接进行一此左旋转
- 如果左子结点是红色的，而且左子结点的左子结点也是红色的，对上层链接进行一次右旋转
- 如果左子结点是红色的，右子结点也是红色的，进行一次颜色转换

请注意：第一步操作包括两种情况，向一个2-结点中插入一个新结点，和插入新结点通过中链接向父结点相连

#### 实现

保持树的平衡性是需要在插入的结点从下至上保持的。把这算法植入到代码中也很简单。只需要在递归调用结束之后进行结点颜色的检查，然后进行一两次的旋转或者一次颜色翻转。

## 红黑树的插入算法

红黑树的插入算法除了三个if语句其他的与标准二叉树相同。第一条if语句将新插入结点或临时4-结点的的红色右链接左旋。第二条if语句两个连续的红色左链接中的上层链接进行右旋。第三条if语句将4-结点进行颜色翻转。

#### 红黑树在插入时保持平衡

如果要插入一个新键，首先会在树中从根结点开始向下查找直到遇到一个相同的键，就更新这个键。或者遇到一个空链接就插入一个新结点并且通过一个红色链接与父结点相连，这个过程是黑链接平衡的，但是可能会有两个个问题。一有可能产生一个红色右链接，这时候我们将它进行左旋操作即可。二是有可能产生两个连续的红链接，这个时侯我们通过0次、1次或2次旋转操作，再加上一次颜色翻转操。递归地在父结点也做这些操作，即可解决这个问题

## 删除操作

和插入操作一样，我们需要定义一系列局部变换来在删除一个结点的时候保持平衡。我们需要在（为了删除一个结点）构造临时4-结点的时候向下进行局部变换保持平衡，还要再删除后递归结束时向上处理遗留的4-结点

#### 自顶向下的2-3-4树

2-3-4树的插入算法，我们需要实现沿着树既能向下变换也能向上变换的算法，沿树向下变换时为了保证底部的树不是4-结点，需要将结点进行分解，将结点中的一部分键送入到父结点中。再递归调用结束后，向上的过程中需要利用旋转将结点配平

#### 删除最小键

我们注意到删除底部的3-结点是非常简单的，只需将3-结点变为2-结点即可。但是删除底部的2-结点则不然，我们可以把删除的2-结点用空链接替代，但是这样会破坏完美平衡性。所以我们要在沿根结点向下的过程中保持结点不是2-结点，可以是3-结点，也可以是临时的4-结点。对于根结点可能有两种情况：如果根结点是2-结点并且它的左右子树都是2结点那就直接将之合并为临时的4-结点。否则需要保证左子结点不是2-结点，必要时候可以从右子结点借一个键来。在沿着左链接向下的过程中，保证以下情况值以成立：

- 如果当前结点的左子结点不是2-结点，完成。
- 如果当前结点的左子结点是2-结点，并且左子结点的亲兄弟结点（离它最近的兄弟结点）不是2-结点，则从它的亲兄弟结点借一个键过来。
- 如果当前结点的左子结点是2-结点，并且它的亲兄弟结点也是2-结点。把当前结点的最小键和左子结点和离它最近的兄弟结点合并为4-结点。把它的父结点由4-结点变为3-结点，或者由3-结点变为2-结点。

在遍历的过程中执行这个过程，我们最终可以得到一个在底部的3-结点或4-结点，然后从中删除一个键。最后向上分解临时的4-结点（将4-结点分解为2个2-结点并且将中键送到父结点中）。

对于红黑树的删除最小键我们只需要保证当前结点的颜色是红色就可以，因为到底部时最小结点为红色的时候，直接删除红色结点，不会影响黑色链接平衡性。

#### 删除操作

和二叉树的删除操作一样，先向下找到相应的结点，然后将该结点右子树的最小键作为后继结点，再将该结点与它的后继结点交换位置，最后以删除右子树最小键的方式删除目标结点。

每次沿左子树或右子树向下查找时必须保证相应的子结点是红色，否则可以使用moveRedLeft()或moveRedRight()方法。

## 红黑树的性质

#### 性能分析

#### 有序符号表API