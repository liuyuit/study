# 二叉查找树

> 二叉查找树的每个结点最多有两个子结点，父结点的键大于左子结点并且小于右子结点。

## 基本实现

#### 数据表示

每个结点含有一个键、值、一条左链接、一条右链接、一个结点计数器

#### 查找

查找从根结点开始，对比查找键和结点键，如果查找键大的话，就递归地从根结点的右子结点开始查找。如果查找键小的话，就递归地从根结点的左子结点开始查找。相等则返回该结点的值

#### 插入

与查找很相似，找到相同的结点就修改值，否则就根据给定键和当前结点键的大小关系来决定继续查找左子树或右子树，直到这个子树是空结点，就返回一个新结点的链接。这就实现了在相应的位置插入一个新结点

#### 递归

对于递归的运行细节我们可以这样理解：对于递归调用前的代码，可以想象沿着树向下走。递归调用后的代码可以想象成沿树往上走

## 分析

## 有序性相关的方法和删除操作

#### 最大键和最小键

取最小键只需查看当前结点是否有左子结点。如果没有则当前结点就是最小键的结点，否则就递归的把左子结点作为当前结点

取最大键则与取最小键同理，只需把左子结点换成右子结点

如果根节点的左链接为空，那么根节点就是最小键。否则递归地从左子树中查找最小键

#### 向下取整和向上取整

如果给定的键key小于根节点的键，那么小于key的最大键一定在根节点的左子树中；如果给定的键大于根结点的键，那么只有当根节点的右子树中存在小于等于key的结点时，目标结点才存在于根节点的右子树中，否则小于key的最大键就是根结点的键。

#### 选择操作

选择操作就是找到排名为k的键（即键中正好右k个小于它的键），如果左子树的结点树t大于k，那么就递归地在左子树中查找排名为k的键。如果t等于k，我们就返回根结点中的键。如果t小于k，我们就递归地在右子树中查找排名为`k – t – 1`的键

#### 排名

排名就是返回给定键key的排名（即右多少键小于给定键），rank()是select()的逆操作，。如果给定的键与根结点的键相等，则返回左子树的结点总数。如果给定键小于根节点的键，那么则递归地在左子树中查找给定键地排名。如果给定键大于根节点的键，则递归地在右子树中查找排名，并且将给定键在右子树中排名加上根结点左子树的总结点数加一。

#### 删除最大键和最小键

删除最小键我们需要从根结点开始，一直递归地查看左子树，直到根节点没有左子树，这时候我们用根节点的右子树替代根结点（只需要将右子树的引用返回给上一个结点，作为上一个结点的左子树）。

同时递归调用后还需要重新计算结点计数器

#### 删除操作

如果要删除的结点只有一个子结点，我们可以用类似于删除最小键的方法。但是如果有两个子结点就需要用这个结点的后继结点去替代该结点，比如待删除结点有右子结点，那么该结点的后继结点就是右子树的最小结点，并且使用executeDeleteMin()删除右子树的最小结点（后继结点）。然后在递归回调结束之后调整结点计数器就好。如果待删除结点有左子结点，方法也是类似

如果要删除的结点只有一个子结点，我们可以用子结点来代替该结点（只需返回子结点即可），但如果要删除的结点有两个子结点，找到一个后继结点来代替该结点，比如把该结点的右子树的最小结点作为后继结点，因为该结点和该后继结点之间没有任何键，这样不会影响树的结构。只需要一下几步即可完成此替换操作

- 将待删除的结点x保存为t
-  将x指向它的后继结点executeMin(t.right)
- 将x.right（原本指向空）指向executeDeleteMin(t.right)，也就是删除后所有结点都大于x.key的子树
-  x.left设为t.left

在递归调用结束后需要重新计算每个结点的结点计数器

#### 范围查找

要实现能够返回给定范围内键的keys()方法，我们首先实现一个遍历二叉查找树的遍历方法—中序遍历。中序遍历需要将所有键按顺序打印出来。要做到这一点我们需要先递归地打印出根结点的左子树所有键，再打印根结点的键，最后递归地打印根结点右子树所有键。

要实现能接受两个参数并且返回给定范围的键的keys()方法，我们需要能够将所有在范围内的键加入到queue中，并且跳过那些不存在给定范围键的子树。

#### 性能分析
