# 连接的原理

> https://juejin.cn/book/6844733769996304392/section/6844733770055024654

join 连接

## 连接简介

### 连接的本质

```
mysql> create table t1(m1 int, n1 char(1) );
mysql> create table t2(m2 int, n2 char(1) );
mysql> INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');
mysql>  INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
```

```
mysql> select * from t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+

mysql> select * from t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
```

连接的本质就是把各个连接表的数据都取出来依次匹配。

```
mysql> select * from t1,t2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    1 | a    |    2 | b    |
|    2 | b    |    2 | b    |
|    3 | c    |    2 | b    |
|    1 | a    |    3 | c    |
|    2 | b    |    3 | c    |
|    3 | c    |    3 | c    |
|    1 | a    |    4 | d    |
|    2 | b    |    4 | d    |
|    3 | c    |    4 | d    |
+------+------+------+------+
```

结果集中包含一个表中每一条数据和另一个表每一条数据相互匹配的组合。这种叫 笛卡儿积

### 连接过程简介

三个 100 行记录的表的笛卡儿积是 100 * 100 * 100 = 1000000。所以我们需要设置过滤条件

- 涉及单表的条件，例如
  - t1.m1 > 1
  - t2.n2 < 'd'
- 涉及两表的条件
  - t1.m1 = t2.m2
  - t1.n1 > t2.n2

执行过程

```
mysql> select * from t1,t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
```

过滤条件

- t1.m1 > 1
- t1.m1 = t2.m2
- t2.n2 < 'd'

执行过程

- 确定第一个需要查询的表（驱动表），用单表查询方法查询 t1 表中符合筛选条件的记录（两条），
- 针对上一步查到的每一条数据，到 t2 表（被驱动表）查询相匹配的记录（符合过滤条件的记录），上一步得到了2 条记录，所以查 2 次 t2 表。此时使用涉及两表的条件 t1.m1 = t2.m2 来过滤。
  - 上一步查到的第一条数据为 t1.m1 = 2，这时  t1.m1 = t2.m2 就相当于   2 = t2.m2 ，此时 t2 表就有两个查询条件 2 = t2.m2  t2.n2 < 'd'，再到 t2 执行单表查询
  - 上一步查到的第二条数据为 t1.m1 = 3，这时  t1.m1 = t2.m2 就相当于   3 = t2.m2 ，此时 t2 表就有两个查询条件 3 = t2.m2  t2.n2 < 'd'，再到 t2 执行单表查询

驱动表只会查询一次，而从驱动表查询到多少条记录，就会从被驱动表查询多少次

### 内连接和外连接

```
mysql> create table student (
    -> number int not null auto_increment comment '学号',
    -> name varchar(5) comment '姓名',
    -> major varchar(30) comment '专业',
    -> primary key (number)
    -> ) Engine=InnoDB  charset=utf8 comment='学生信息表';

mysql> CREATE TABLE score (
    ->     number INT COMMENT '学号',
    ->     subject VARCHAR(30) COMMENT '科目',
    ->     score TINYINT COMMENT '成绩',
    ->     PRIMARY KEY (number, subject)
    -> ) Engine=InnoDB CHARSET=utf8 COMMENT '学生成绩表';
```

插入数据

```
mysql> insert into student(number, name, major) values(20180101, '杜同学', '软件学院' ),(20180102, '范同学', '计算机科学与工程' ),(20180103 , '史同学', '计算机科学与工程');
mysql> select * from student;
+----------+-----------+--------------------------+
| number   | name      | major                    |
+----------+-----------+--------------------------+
| 20180101 | 杜同学    | 软件学院                 |
| 20180102 | 范同学    | 计算机科学与工程         |
| 20180103 | 史同学    | 计算机科学与工程         |
+----------+-----------+--------------------------+


mysql> insert into score (number, subject, score) values (20180101,'母猪的产后护理',78),(20180101,'论萨达姆的战争准备',88),(20180102,'论萨达姆的战争准备',98),(20180102,'母猪的产后护理',100);
mysql> select * from score;
+----------+-----------------------------+-------+
| number   | subject                     | score |
+----------+-----------------------------+-------+
| 20180101 | 母猪的产后护理              |    78 |
| 20180101 | 论萨达姆的战争准备          |    88 |
| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------------------------+-------+

```

两表连接

```
mysql> select * from student,score where student.number = score.number;
+----------+-----------+-----------------+----------+------------------+-------+
| number   | name      | major           | number   | subject         | score |
+----------+-----------+------------+----------+-----------------------------+-------+
| 20180101 | 杜同学    | 软件学院      | 20180101 | 母猪的产后护理              |    78 |
| 20180101 | 杜同学    | 软件学院      | 20180101 | 论萨达姆的战争准备          |    88 |
| 20180102 | 范同学    | 计算机科学与工程| 20180102 | 母猪的产后护理              |   100 |
| 20180102 | 范同学    | 计算机科学与工程| 20180102 | 论萨达姆的战争准备          |    98 |
+----------+-----------+------------+----------+-----------------------------+-------+
4 rows in set (0.00 sec)
```

```
mysql> SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number   | name      | subject                     | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜同学    | 母猪的产后护理              |    78 |
| 20180101 | 杜同学    | 论萨达姆的战争准备          |    88 |
| 20180102 | 范同学    | 母猪的产后护理              |   100 |
| 20180102 | 范同学    | 论萨达姆的战争准备          |    98 |
+----------+-----------+-----------------------------+-------+
4 rows in set (0.00 sec)
```

史同学缺考了，所以没有查出来。有时候我们希望把缺考的也显示出来。

对于从驱动表查出的每一条记录，即使在被驱动表里没有相匹配的数据也要显示在最终结果中。

- **内连接**：驱动表的中记录在被驱动表中找不到匹配的记录，就不会显示在结果中。上述的都是内连接。

- **外连接**，即使驱动表的中记录在被驱动表中找不到匹配的记录，也会显示在结果中

  - 左外连接

    左侧表为驱动表

  - 右外连接

    右侧表为驱动表

过滤条件

- where

  无论内连接还是外连接，不符合 where 条件的都不会加入到结果。

- on

  对于外连接，如果驱动表的某条记录，被驱动表中没有符合 on 条件的记录，这条记录仍然会出现在结果中，被驱动表中字段会被 null 代替。

  在内连接中，被驱动表存在匹配的记录才会显示在结果中。

#### 左（外）连接的语法

```
select * from t1 left [outer] join on connect_condition [where normal_condition];
```

对于 left join ，左表名为外表或驱动表，右表名为内表或被驱动表。外连接必须用on 语句。

```
mysql> SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 left outer join score AS s2 on s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number   | name      | subject                     | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜同学    | 母猪的产后护理              |    78 |
| 20180101 | 杜同学    | 论萨达姆的战争准备          |    88 |
| 20180102 | 范同学    | 母猪的产后护理              |   100 |
| 20180102 | 范同学    | 论萨达姆的战争准备          |    98 |
| 20180103 | 史同学    | NULL                        |  NULL |
+----------+-----------+-----------------------------+-------+
```

#### 右（外连接）的语法

```
select * from t1 right [outer] join on connect_condition [where normal_condition];
```

右表是驱动表，左表是被驱动表

#### 内连接的语法

内外连接的区别是当被驱动表中没有符合 on 条件的记录时会不会加入到结果集中。

```
select * from t1 [inner | cross] join t2 [on connection_condition] [where normal_condition];
```

内连接一下写法等价

- select * from t1 join t2;
- select * from t1 inner join t2;
- select * from t1  cross join t2;
- select * from t1,t2;

内外连接不管哪个表作为驱动表，产生的笛卡儿积是一样的，但是内连接会把不符合 on 条件的过滤掉

#### 小结

```
mysql> select * from t1 inner join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> select * from t1 left join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
|    1 | a    | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t1 right join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
3 rows in set (0.00 sec)
```

## 连接的原理

mysql 进行表连接的算法

### 嵌套循环连接（nested-loop join）

内连接的过程

- 步骤一，选取驱动表，使用与驱动表相关的过滤条件，做单表查询
- 步骤二，对于上一步骤得到的每一条记录，都分别从被驱动表中查询相匹配的记录

如果是 3 个表进行连接，步骤 2  得到的结果集就相当于一个新的驱动表。第三个表成了被驱动表

```
for each row in t1{
	for each row in t2{
		for each row in t2{
		
		}
	}
}
```

驱动表只查询一次，从驱动表表中得到多少数据就查询多少次被驱动表。这种叫做嵌套循环连接（nested-loop join）

### 使用索引加快连接速度

上述的步骤二中，查询被驱动表也是单表查询，也可能用到索引

```
mysql> select  * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
```

第一步会根据涉及到驱动表的条件，查询驱动表

```
mysql> select * from t1 where t1.m1 > 1 ;
+------+------+
| m1   | n1   |
+------+------+
|    2 | b    |
|    3 | c    |
+------+------+
```

然后根据这个结果去查询被驱动表

- 当 t1.m1 = 2 时，对被驱动表 t2 的查询相当于

  ```
  mysql> select * from t2 where t2.m2 = 2 and t2.n2 < 'd' ;
  ```

- 当 t1.m1 = 3 时，对被驱动表 t2 的查询相当于

  ```
  mysql> select * from t2 where t2.m2 = 3 and t2.n2 < 'd' ;
  ```

可以看到，在查询 t2 表时， t1.m1 = t2.m2 这个涉及两表的条件，因为 t1.m1 的值已经确定，这个条件也变成只涉及 t2 表了。所以单独对 t2 表做优化即可。可以在 t2.m2 或 t2.n2 上建立索引

#### 基于块的嵌套循环连接（Block Nested-loop Join）

嵌套循环连接中，对于从驱动表查询到的每一条记录，都会到被驱动表匹配查询一次。每次查询都会将数据从磁盘加载到内存中，查完后从内存中清除掉。然后再从驱动表结果集中取一条数据，再把被驱动表从磁盘加载到内存中。这个 I/O 代价较大。

我们可以把驱动表结果集放到 join buffer 中，然后开始扫描被驱动表，每一条被驱动表都和join buffer 中的每一条记录做匹配。这样可以减少 被驱动表的 I/O 代价

驱动表结果集中的查询列和过滤条件列才会加入到 join buffer 中。

