# 25、锁

> https://juejin.cn/book/6844733769996304392/section/6844733770071801864

## 解决并发事务带来问题的两种基本方式

并发事务访问相同记录的情况大致可以划分为3

- `读-读`情况：即并发事务相继读取相同的记录。

  读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。

- `写-写`情况：即并发事务相继对相同的记录做出改动。

  在多个未提交事务相继对一条记录做改动时，需要让它们排队执行

  当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的`锁结构`，当没有的时候就会在内存中生成一个`锁结构`与之关联

  锁结构两个比较重要的属性：

  - `trx信息`：代表这个锁结构是哪个事务生成的。
  - `is_waiting`：代表当前事务是否在等待。

  几种说法：

  - 不加锁

    意思就是不需要在内存中生成对应的`锁结构`，可以直接执行操作。

  - 获取锁成功，或者加锁成功

    意思就是在内存中生成了对应的`锁结构`，而且锁结构的`is_waiting`属性为`false`，也就是事务可以继续执行操作。

  - 获取锁失败，或者加锁失败，或者没有获取到锁

    意思就是在内存中生成了对应的`锁结构`，不过锁结构的`is_waiting`属性为`true`，也就是事务需要等待，不可以继续执行操作。

- `读-写`或`写-读`情况：也就是一个事务进行读取操作，另一个进行改动操作。

  - 方案一：读操作利用多版本并发控制（`MVCC`），写操作进行`加锁`。

    查询语句只能读到在生成`ReadView`之前已提交事务所做的更改。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用`MVCC`时，`读-写`操作并不冲突。

  - 方案二：读、写操作都采用`加锁`的方式。

    如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本

    这样在读取记录的时候也就需要对其进行`加锁`操作，这样也就意味着`读`操作和`写`操作也像`写-写`操作那样排队执行。

采用`MVCC`方式的话，`读-写`操作彼此并不冲突，性能更高，采用`加锁`方式的话，`读-写`操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用`MVCC`来解决`读-写`操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用`加锁`的方式执行

### 一致性读（Consistent Reads）

事务利用`MVCC`进行的读取操作称之为`一致性读`，或者`一致性无锁读`，有的地方也称之为`快照读`。所有普通的`SELECT`语句（`plain SELECT`）在`READ COMMITTED`、`REPEATABLE READ`隔离级别下都算是`一致性读`，比方说：

```
SELECT * FROM t;
SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2
```

`一致性读`并不会对表中的任何记录做`加锁`操作，其他事务可以自由的对表中的记录做改动。

### 锁定读（Locking Reads）

#### 共享锁和独占锁

既要允许`读-读`情况不受影响，又要使`写-写`、`读-写`或`写-读`情况中的操作相互阻塞，所以设计`MySQL`的大叔给锁分了个类：

- `共享锁`，英文名：`Shared Locks`，简称`S锁`。在事务要读取一条记录时，需要先获取该记录的`S锁`。
- `独占锁`，也常称`排他锁`，英文名：`Exclusive Locks`，简称`X锁`。在事务要改动一条记录时，需要先获取该记录的`X锁`。

假如事务`T1`首先获取了一条记录的`S锁`之后，事务`T2`接着也要访问这条记录：

- 如果事务`T2`想要再获取一个记录的`S锁`，那么事务`T2`也会获得该锁，也就意味着事务`T1`和`T2`在该记录上同时持有`S锁`。
- 如果事务`T2`想要再获取一个记录的`X锁`，那么此操作会被阻塞，直到事务`T1`提交之后将`S锁`释放掉。

| 兼容性 | `X`    | `S`    |
| ------ | ------ | ------ |
| `X`    | 不兼容 | 不兼容 |
| `S`    | 不兼容 | 兼容   |

#### 锁定读的语句

- 对读取的记录加`S锁`：

  ```
  SELECT ... LOCK IN SHARE MODE;
  ```

- 对读取的记录加`X锁`：

  ```
  SELECT ... FOR UPDATE;
  ```

### 写操作

- `DELETE`：

  我们也可以把这个定位待删除记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。

- `UPDATE`：

  三种情况：

  - 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。
  - 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护。
  - 如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了。

- `INSERT`：

  一般情况下，新插入一条记录的操作并不加锁，设计`InnoDB`的大叔通过一种称之为`隐式锁`的东东来保护这条新插入的记录在本事务提交前不被别的事务访问

## 多粒度锁

前边提到的`锁`都是针对记录的，也可以被称之为`行级锁`或者`行锁`

一个事务也可以在`表`级别进行加锁，自然就被称之为`表级锁`或者`表锁`。给表加的锁也可以分为`共享锁`（`S锁`）和`独占锁`（`X锁`）：

- 给表加`S锁`：

  如果一个事务给表加了`S锁`，那么：

  - 别的事务可以继续获得该表的`S锁`
  - 别的事务可以继续获得该表中的某些记录的`S锁`
  - 别的事务不可以继续获得该表的`X锁`
  - 别的事务不可以继续获得该表中的某些记录的`X锁`

- 给表加`X锁`：

  如果一个事务给表加了`X锁`（意味着该事务要独占这个表），那么：

  - 别的事务不可以继续获得该表的`S锁`
  - 别的事务不可以继续获得该表中的某些记录的`S锁`
  - 别的事务不可以继续获得该表的`X锁`
  - 别的事务不可以继续获得该表中的某些记录的`X锁`

但是这里头有两个问题：

- 如果我们想上`S表锁`，首先需要确保表中没有行级  x锁
- 如果我们想上`X表锁`，首先需要确保表中没有 x锁或者 s锁

于是乎设计`InnoDB`的大叔们提出了一种称之为`意向锁`（英文名：`Intention Locks`）

- 意向共享锁，英文名：`Intention Shared Lock`，简称`IS锁`。当事务准备在某条记录上加`S锁`时，需要先在表级别加一个`IS锁`。
- 意向独占锁，英文名：`Intention Exclusive Lock`，简称`IX锁`。当事务准备在某条记录上加`X锁`时，需要先在表级别加一个`IX锁`。

## MySQL中的行锁和表锁

### 其他存储引擎中的锁

对于`MyISAM`、`MEMORY`、`MERGE`这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。

### InnoDB存储引擎中的锁

`InnoDB`存储引擎既支持表锁，也支持行锁

#### InnoDB中的表级锁

- 表级别的`S锁`、`X锁`

  在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行诸如`SELECT`、`INSERT`、`DELETE`、`UPDATE`的语句会发生阻塞，同理，某个事务中对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。这个过程其实是通过在`server层`使用一种称之为`元数据锁`（英文名：`Metadata Locks`，简称`MDL`）东东来实现的

  `InnoDB`存储引擎提供的表级`S锁`或者`X锁`是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到

- 表级别的`IS锁`、`IX锁

- 表级别的`AUTO-INC锁`

  在使用`MySQL`过程中，我们可以为表的某个列添加`AUTO_INCREMENT`属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值

系统实现这种自动给`AUTO_INCREMENT`修饰的列递增赋值的原理主要是两个：

- 采用`AUTO-INC`锁，也就是在执行插入语句时就在表级别加一个`AUTO-INC`锁，然后为每条待插入记录的`AUTO_INCREMENT`修饰的列分配递增的值。

  如果我们的插入语句在执行前不可以确定具体要插入多少条记录，比方说使用`INSERT ... SELECT`、`REPLACE ... SELECT`或者`LOAD DATA`这种插入语句，一般是使用`AUTO-INC`锁为`AUTO_INCREMENT`修饰的列生成对应的值

- 采用一个轻量级的锁，在为插入语句生成`AUTO_INCREMENT`修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的`AUTO_INCREMENT`列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

#### InnoDB中的行级锁

```
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

我们主要是想用这个表存储三国时的英雄，然后向这个表里插入几条记录：

```
INSERT INTO hero VALUES
    (1, 'l刘备', '蜀'),
    (3, 'z诸葛亮', '蜀'),
    (8, 'c曹操', '魏'),
    (15, 'x荀彧', '魏'),
    (20, 's孙权', '吴');
```

现在表里的数据就是这样的：

```
mysql> SELECT * FROM hero;
+--------+------------+---------+
| number | name       | country |
+--------+------------+---------+
|      1 | l刘备      | 蜀      |
|      3 | z诸葛亮    | 蜀      |
|      8 | c曹操      | 魏      |
|     15 | x荀彧      | 魏      |
|     20 | s孙权      | 吴      |
+--------+------------+---------+
5 rows in set (0.01 sec)
```

- `Record Locks`：

  官方的类型名称为：`LOCK_REC_NOT_GAP`。比方说我们把`number`值为`8`的那条记录加一个`Record Locks`

  

  ![image_1d9etchk0136o49c13t81bn81d3m.png-88.1kB](https://user-gold-cdn.xitu.io/2019/4/27/16a5ddeea00f72b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  `正经记录锁`是有`S锁`和`X锁`之分的，让我们分别称之为`S型正经记录锁`和`X型正经记录锁`吧（听起来有点怪怪的），当一个事务获取了一条记录的`S型正经记录锁`后，其他事务也可以继续获取该记录的`S型正经记录锁`，但不可以继续获取`X型正经记录锁`；当一个事务获取了一条记录的`X型正经记录锁`后，其他事务既不可以继续获取该记录的`S型正经记录锁`，也不可以继续获取`X型正经记录锁`；

- `Gap Locks`：

  我们说`MySQL`在`REPEATABLE READ`隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用`MVCC`方案解决，也可以采用`加锁`方案解决。但是在使用`加锁`方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上`正经记录锁`。不过这难不倒设计`InnoDB`的大叔，他们提出了一种称之为`Gap Locks`的锁，官方的类型名称为：`LOCK_GAP`，我们也可以简称为`gap锁`。比方说我们把`number`值为`8`的那条记录加一个`gap锁`的示意图如下：

  

  ![image_1d9etbrl938j1v2h1mmjh42e0f9.png-85.7kB](https://user-gold-cdn.xitu.io/2019/4/27/16a5ddeea09f4b64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  如图中为`number`值为`8`的记录加了`gap锁`，意味着不允许别的事务在`number`值为`8`的记录前边的`间隙`插入新记录

  那对于最后一条记录之后的间隙，也就是`hero`表中`number`值为`20`的记录之后的间隙该咋办呢？也就是说给哪条记录加`gap锁`才能阻止其他事务插入`number`值在`(20, +∞)`这个区间的新记录呢？这时候应该想起我们在前边唠叨`数据页`时介绍的两条伪记录了：

  - `Infimum`记录，表示该页面中最小的记录。
  - `Supremum`记录，表示该页面中最大的记录。

  我们可以给索引中的最后一条记录，也就是`number`值为`20`的那条记录所在页面的`Supremum`记录加上一个`gap锁`，画个图就是这样：

  

  ![image_1d9mnrs6o18f61jel8juvm4o127o.png-98.5kB](https://user-gold-cdn.xitu.io/2019/4/30/16a6dd4244481b96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  这样就可以阻止其他事务插入`number`值在`(20, +∞)`这个区间的新记录。

- `Next-Key Locks`：

  

  

  ![image_1d9mo12guolk1amr1bde1ahjgti85.png-98.6kB](https://user-gold-cdn.xitu.io/2019/4/30/16a6dd42446ce8b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  `next-key锁`的本质就是一个`正经记录锁`和一个`gap锁`的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的`间隙`。

- `Insert Intention Locks`：

  我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的`gap锁`，如果有的话，插入操作需要等待，直到拥有`gap锁`的那个事务提交。但是设计`InnoDB`的大叔规定事务在等待的时候也需要在内存中生成一个`锁结构`，表明有事务想在某个`间隙`中插入新记录，但是现在在等待。设计`InnoDB`的大叔就把这种类型的锁命名为`Insert Intention Locks`，官方的类型名称为：`LOCK_INSERT_INTENTION`，我们也可以称为`插入意向锁`。

  比方说我们把`number`值为`8`的那条记录加一个`插入意向锁`的示意图如下：

  

  ![image_1d9mo381821h17u16r4p64lb58v.png-100.5kB](https://user-gold-cdn.xitu.io/2019/4/30/16a6dd424353495e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  为了让大家彻底理解这个`插入意向锁`的功能，我们还是举个例子然后画个图表示一下。比方说现在`T1`为`number`值为`8`的记录加了一个`gap锁`，然后`T2`和`T3`分别想向`hero`表中插入`number`值分别为`4`、`5`的两条记录，所以现在为`number`值为`8`的记录加的锁的示意图就如下所示：

  

  ![image_1d9p8551i7sf1hfpbtb1eiu6vf9.png-104.5kB](https://user-gold-cdn.xitu.io/2019/5/1/16a72bf8133eb1dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  > 小贴士： 我们在锁结构中又新添了一个type属性，表明该锁的类型。稍后会全面介绍InnoDB存储引擎中的一个锁结构到底长什么样。

  从图中可以看到，由于`T1`持有`gap锁`，所以`T2`和`T3`需要生成一个`插入意向锁`的`锁结构`并且处于等待状态。当`T1`提交后会把它获取到的锁都释放掉，这样`T2`和`T3`就能获取到对应的`插入意向锁`了（本质上就是把插入意向锁对应锁结构的`is_waiting`属性改为`false`），`T2`和`T3`之间也并不会相互阻塞，它们可以同时获取到`number`值为8的`插入意向锁`，然后执行插入操作。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（`插入意向锁`就是这么鸡肋）。

- 隐式锁

  我们前边说一个事务在执行`INSERT`操作时，如果即将插入的`间隙`已经被其他事务加了`gap锁`，那么本次`INSERT`操作会阻塞，并且当前事务会在该间隙上加一个`插入意向锁`，否则一般情况下`INSERT`操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：

  - 立即使用`SELECT ... LOCK IN SHARE MODE`语句读取这条记录，也就是在要获取这条记录的`S锁`，或者使用`SELECT ... FOR UPDATE`语句读取这条记录，也就是要获取这条记录的`X锁`，该咋办？

    如果允许这种情况的发生，那么可能产生`脏读`问题。

  - 立即修改这条记录，也就是要获取这条记录的`X锁`，该咋办？

    如果允许这种情况的发生，那么可能产生`脏写`问题。

  这时候我们前边唠叨了很多遍的`事务id`又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：

  - 情景一：对于聚簇索引记录来说，有一个`trx_id`隐藏列，该隐藏列记录着最后改动该记录的`事务id`。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的`trx_id`隐藏列代表的的就是当前事务的`事务id`，如果其他事务此时想对该记录添加`S锁`或者`X锁`时，首先会看一下该记录的`trx_id`隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个`X锁`（也就是为当前事务创建一个锁结构，`is_waiting`属性是`false`），然后自己进入等待状态（也就是为自己也创建一个锁结构，`is_waiting`属性是`true`）。
  - 情景二：对于二级索引记录来说，本身并没有`trx_id`隐藏列，但是在二级索引页面的`Page Header`部分有一个`PAGE_MAX_TRX_ID`属性，该属性代表对该页面做改动的最大的`事务id`，如果`PAGE_MAX_TRX_ID`属性值小于当前最小的活跃`事务id`，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复`情景一`的做法。

  通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于`事务id`这个牛逼的东东的存在，相当于加了一个`隐式锁`。别的事务在对这条记录加`S锁`或者`X锁`时，由于`隐式锁`的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

### InnoDB锁的内存结构

我们前边说对一条记录加锁的本质就是在内存中创建一个`锁结构`与之关联，那么是不是一个事务对多条记录加锁，就要创建多个`锁结构`呢？比方说事务`T1`要执行下边这个语句：

```
# 事务T1
SELECT * FROM hero LOCK IN SHARE MODE;
```

设计`InnoDB`的大叔本着勤俭节约的传统美德，决定在对不同记录加锁时，如果符合下边这些条件：

- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的

只有被加锁的记录 id 不同

那么这些记录的锁就可以被放到一个`锁结构`中。



![image_1d9kcpbl5178l1i691bg21jk61lv09.png-101.8kB](https://user-gold-cdn.xitu.io/2019/4/29/16a68cda54348429?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们看看这个结构里边的各种信息都是干嘛的：

- `锁所在的事务信息`：

- `索引信息`

- `表锁／行锁信息`：

  `表锁结构`和`行锁结构`在这个位置的内容是不同的：

  - 表锁：

    记载着这是对哪个表加的锁，还有其他的一些信息。

  - 行锁：

    记载了三个重要的信息：

    - `Space ID`：记录所在表空间。
    - `Page Number`：记录所在页号。
    - `n_bits`：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个`n_bits`属性代表使用了多少比特位。

    > 小贴士： 并不是该页面中有多少记录，n_bits属性的值就是多少。为了让之后在页面中插入了新记录后也不至于重新分配锁结构，所以n_bits的值一般都比页面中记录条数多一些。

- `type_mode`：

  这是一个32位的数，被分成了`lock_mode`、`lock_type`和`rec_lock_type`三个部分，如图所示：

  

  ![img](https://user-gold-cdn.xitu.io/2019/5/5/16a864f3298df751?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  - 锁的模式（`lock_mode`），占用低4位，可选的值如下：

    - `LOCK_IS`（十进制的`0`）：表示共享意向锁，也就是`IS锁`。
    - `LOCK_IX`（十进制的`1`）：表示独占意向锁，也就是`IX锁`。
    - `LOCK_S`（十进制的`2`）：表示共享锁，也就是`S锁`。
    - `LOCK_X`（十进制的`3`）：表示独占锁，也就是`X锁`。
    - `LOCK_AUTO_INC`（十进制的`4`）：表示`AUTO-INC锁`。

    > 小贴士： 在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。

  - 锁的类型（`lock_type`），占用第5～8位，不过现阶段只有第5位和第6位被使用：

    - `LOCK_TABLE`（十进制的`16`），也就是当第5个比特位置为1时，表示表级锁。
    - `LOCK_REC`（十进制的`32`），也就是当第6个比特位置为1时，表示行级锁。

  - 行锁的具体类型（`rec_lock_type`），使用其余的位来表示。只有在`lock_type`的值为`LOCK_REC`时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：

    - `LOCK_ORDINARY`（十进制的`0`）：表示`next-key锁`。
    - `LOCK_GAP`（十进制的`512`）：也就是当第10个比特位置为1时，表示`gap锁`。
    - `LOCK_REC_NOT_GAP`（十进制的`1024`）：也就是当第11个比特位置为1时，表示`正经记录锁`。
    - `LOCK_INSERT_INTENTION`（十进制的`2048`）：也就是当第12个比特位置为1时，表示插入意向锁。
    - 其他的类型：还有一些不常用的类型我们就不多说了。

    怎么还没看见`is_waiting`属性呢？这主要还是设计`InnoDB`的大叔太抠门了，一个比特位也不想浪费，所以他们把`is_waiting`属性也放到了`type_mode`这个32位的数字中：

    - `LOCK_WAIT`（十进制的`256`） ：也就是当第9个比特位置为`1`时，表示`is_waiting`为`true`，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为`0`时，表示`is_waiting`为`false`，也就是当前事务获取锁成功。

- `其他信息`：

  为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表，为了简化讨论，我们忽略这部分信息哈～

- `一堆比特位`：

  如果是`行锁结构`的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的`n_bits`属性表示的。我们前边唠叨InnoDB记录结构的时候说过，页面中的每条记录在`记录头信息`中都包含一个`heap_no`属性，伪记录`Infimum`的`heap_no`值为`0`，`Supremum`的`heap_no`值为`1`，之后每插入一条记录，`heap_no`值就增1。`锁结构`最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个`heap_no`，不过为了编码方便，映射方式有点怪：

  

  ![image_1d9kpvbp118va1enl1hmbpon1j4j13.png-53.1kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7b413698?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

  > 小贴士： 这么怪的映射方式纯粹是为了敲代码方便，大家不要大惊小怪，只需要知道一个比特位映射到页内的一条记录就好了。

可能上边的描述大家觉得还是有些抽象，我们还是举个例子说明一下。比方说现在有两个事务`T1`和`T2`想对`hero`表中的记录进行加锁，`hero`表中记录比较少，假设这些记录都存储在所在的表空间号为`67`，页号为`3`的页面上，那么如果：

- `T1`想对`number`值为`15`的这条记录加`S型正常记录锁`，在对记录加行锁之前，需要先加表级别的`IS`锁，也就是会生成一个表级锁的内存结构，不过我们这里不关心表级锁，所以就忽略掉了哈～ 接下来分析一下生成行锁结构的过程：

  - 事务`T1`要进行加锁，所以锁结构的`锁所在事务信息`指的就是`T1`。

  - 直接对聚簇索引进行加锁，所以索引信息指的其实就是`PRIMARY`索引。

  - 由于是行锁，所以接下来需要记录的是三个重要信息：

    - `Space ID`：表空间号为`67`。

    - `Page Number`：页号为`3`。

    - `n_bits`：我们的`hero`表中现在只插入了5条用户记录，但是在初始分配比特位时会多分配一些，这主要是为了在之后新增记录时不用频繁分配比特位。其实计算`n_bits`有一个公式：

      ```
      n_bits = (1 + ((n_recs + LOCK_PAGE_BITMAP_MARGIN) / 8)) * 8
      ```

      其中`n_recs`指的是当前页面中一共有多少条记录（算上伪记录和在垃圾链表中的记录），比方说现在`hero`表一共有7条记录（5条用户记录和2条伪记录），所以`n_recs`的值就是`7`，`LOCK_PAGE_BITMAP_MARGIN`是一个固定的值`64`，所以本次加锁的`n_bits`值就是：

      ```
      n_bits = (1 + ((7 + 64) / 8)) * 8 = 72
      ```

    - `type_mode`是由三部分组成的：

      - `lock_mode`，这是对记录加`S锁`，它的值为`LOCK_S`。
      - `lock_type`，这是对记录进行加锁，也就是行锁，所以它的值为`LOCK_REC`。
      - `rec_lock_type`，这是对记录加`正经记录锁`，也就是类型为`LOCK_REC_NOT_GAP`的锁。另外，由于当前没有其他事务对该记录加锁，所以应当获取到锁，也就是`LOCK_WAIT`代表的二进制位应该是0。

    综上所属，此次加锁的`type_mode`的值应该是：

    ```
    type_mode = LOCK_S | LOCK_REC | LOCK_REC_NOT_GAP
    也就是：
    type_mode = 2 | 32 | 1024 = 1058
    ```

  - 其他信息

    略～

  - 一堆比特位

    因为`number`值为`15`的记录`heap_no`值为`5`，根据上边列举的比特位和`heap_no`的映射图来看，应该是第一个字节从低位往高位数第6个比特位被置为1，就像这样：

    

    ![image_1d9kq7qjukjuafo1rq11pf6d8k1g.png-22.2kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7bef6067?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

  综上所述，事务`T1`为`number`值为5的记录加锁生成的锁结构就如下图所示：

  

  ![image_1d9kqjkqs17hf1u6na2j144d1v0r1t.png-47.9kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7c2efcc5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

- `T2`想对`number`值为`3`、`8`、`15`的这三条记录加`X型的next-key锁`，在对记录加行锁之前，需要先加表级别的`IX`锁，也就是会生成一个表级锁的内存结构，不过我们这里不关心表级锁，所以就忽略掉了哈～

  现在`T2`要为3条记录加锁，`number`为`3`、`8`的两条记录由于没有其他事务加锁，所以可以成功获取这条记录的`X型next-key锁`，也就是生成的锁结构的`is_waiting`属性为`false`；但是`number`为`15`的记录已经被`T1`加了`S型正经记录锁`，`T2`是不能获取到该记录的`X型next-key锁`的，也就是生成的锁结构的`is_waiting`属性为`true`。因为等待状态不相同，所以这时候会生成两个`锁结构`。这两个锁结构中相同的属性如下：

  - 事务`T2`要进行加锁，所以锁结构的`锁所在事务信息`指的就是`T2`。

  - 直接对聚簇索引进行加锁，所以索引信息指的其实就是`PRIMARY`索引。

  - 由于是行锁，所以接下来需要记录是三个重要信息：

    - `Space ID`：表空间号为`67`。
    - `Page Number`：页号为`3`。
    - `n_bits`：此属性生成策略同`T1`中一样，该属性的值为`72`。
    - `type_mode`是由三部分组成的：
      - `lock_mode`，这是对记录加`X锁`，它的值为`LOCK_X`。
      - `lock_type`，这是对记录进行加锁，也就是行锁，所以它的值为`LOCK_REC`。
      - `rec_lock_type`，这是对记录加`next-key锁`，也就是类型为`LOCK_ORDINARY`的锁。

  - 其他信息

    略～

  不同的属性如下：

  - 为`number`为`3`、`8`的记录生成的`锁结构`：

    - `type_mode`值。

      由于可以获取到锁，所以`is_waiting`属性为`false`，也就是`LOCK_WAIT`代表的二进制位被置0。所以：

      ```
      type_mode = LOCK_X | LOCK_REC |LOCK_ORDINARY
      也就是
      type_mode = 3 | 32 | 0 = 35
      ```

    - `一堆比特位`

      因为`number`值为`3`、`8`的记录`heap_no`值分别为`3`、`4`，根据上边列举的比特位和`heap_no`的映射图来看，应该是第一个字节从低位往高位数第4、5个比特位被置为1，就像这样：

    

    ![image_1d9krhp4f1gd7hb4nhv1j182cb2q.png-21.2kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7c3dae70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

    综上所述，事务`T2`为`number`值为`3`、`8`两条记录加锁生成的锁结构就如下图所示：

    

    ![image_1d9krl3im1qr2tb4k1810bs18ak37.png-40.4kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7c619501?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

  - 为`number`为`15`的记录生成的`锁结构`：

    - `type_mode`值。

      由于不可以获取到锁，所以`is_waiting`属性为`true`，也就是`LOCK_WAIT`代表的二进制位被置1。所以：

      ```
      type_mode = LOCK_X | LOCK_REC |LOCK_ORDINARY | LOCK_WAIT
      也就是
      type_mode = 3 | 32 | 0 | 256 = 291
      ```

    - `一堆比特位`

      因为`number`值为`15`的记录`heap_no`值为`5`，根据上边列举的比特位和`heap_no`的映射图来看，应该是第一个字节从低位往高位数第6个比特位被置为1，就像这样：

    

    ![image_1d9krpp171m7r2prc8cnhu1hkf3k.png-20.5kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c2f7ed5108c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

    综上所述，事务`T2`为`number`值为`15`的记录加锁生成的锁结构就如下图所示：

    

    ![image_1d9krv36o145ub7vdr4cap16bq4h.png-43.4kB](https://user-gold-cdn.xitu.io/2019/4/29/16a69c30d7c6b297?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

综上所述，事务`T1`先获取`number`值为`15`的`S型正经记录锁`，然后事务`T2`获取`number`值为`3`、`8`、`15`的`X型正经记录锁`共需要生成3个锁结构。噗～ 关于锁结构我本来就想写一点点的，没想到一写起来就停不下了，大家乐呵乐呵看哈～

> 小贴士： 上边事务T2在对number值分别为3、8、15这三条记录加锁的情景中，是按照先对number值为3的记录加锁、再对number值为8的记录加锁，最后对number值为15的记录加锁的顺序进行的，如果我们一开始就对number值为15的记录加锁，那么该事务在为number值为15的记录生成一个锁结构后，直接就进入等待状态，就不为number值为3、8的两条记录生成锁结构了。在事务T1提交后会把在number值为15的记录上获取的锁释放掉，然后事务T2就可以获取该记录上的锁，这时再对number值为3、8的两条记录加锁时，就可以复用之前为number值为15的记录加锁时生成的锁结构了。

## 语句加锁分析

当然，本文只是解释了`InnoDB`存储引擎中各种锁是个啥以及它们对应的内存锁结构，不过相信各位小伙伴对“锁”的概念其实还不是特别明晰，就是具体的某条语句到底应该加哪些锁。哈哈，语句加锁分析是个非常大的命题，如果有同学想深入学习关于“锁”的这一部分知识，请关注我的微信公众号 「我们都是小青蛙」



![img](https://user-gold-cdn.xitu.io/2019/4/17/16a2906348ab7f5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



之后输入关键字“锁”，即可获取三篇语句加锁分析文章，看完有收获一定要来转发吼，么么哒～