# 基于规则的优化

> https://juejin.cn/book/6844733769996304392/section/6844733770059218951

mysql 查询重写会一些性能差的查询语句转化为性能更高的语句。

## 条件化简

### 移除不必要的括号

```
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
```

equal

```
(a = 5 AND b = c) OR (a > c AND c < 5)
```

### 常量传递

```
a = 5 AND b > a
```

equal

```
a = 5 AND b > 5
```

### 等值传递（equality_propagation）

```
a = b and b = c and c = 5
```

equal

```
a = 5 and b = 5 and c = 5
```

### 移除没用的条件（trivial_condition_removal）

```
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
```

 b = b 永远为 true ， 5 != 5 永远为 false

equal

```
(a < 1 and true) OR (a = 6 OR false)
```

equal

```
a < 1 OR a = 6
```

### 表达式计算

如果表达式中只包含常量，它会被计算出来

```
a = 5 + 1
```

transform

```
a = 6
```

如果某个列出现在表达式或函数中，不会转化，例如

```
ABS(a) > 5
```

```
-a < -8
```

### HAVING 子句和 WHERE 子句合并

如果查询语句没有 sum max 等聚集函数和 group by 子句，mysql 会将 HAVING 子句和 WHERE 子句合并

### 常量表检测

连表时，当某个表中只有一条数据或者用主键或唯一键等值查询时，会先把这张表的记录查出来，并将查询中涉及到这张表的条件全部替换成常量（这条记录的真实值）。

```
SELECT * FROM table1 INNER JOIN table2
    ON table1.column1 = table2.column2 
    WHERE table1.primary_key = 1;
```

equal

```
SELECT table1.column_valus,table2* FROM table1 INNER JOIN table2
    ON table1.column1的常量值 = table2.column2 
    ;
```

## 外连接消除

```
CREATE TABLE t1 (
    m1 int, 
    n1 char(1)
) Engine=InnoDB, CHARSET=utf8;

CREATE TABLE t2 (
    m2 int, 
    n2 char(1)
) Engine=InnoDB, CHARSET=utf8;
```

```
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
```

```
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
|    1 | a    | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)
```

外连接的驱动表和被驱动表都是指定的，所以不能进行连接顺序优化

外连接和内连接的区别在于，外连接的驱动表的某条记录，如果在被驱动表中找不到相匹配的记录，这条记录仍然会加入到结果集中，但是对应的被驱动表的字段会被 null 填充

如果 where 中指定了，被驱动表的字段不能为 null，那么外连接等价于内连接。

例如

```
mysql> select * from t1 left join t2 on t1.n1 = t2.n2 where  t2.m2 is not null;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)
```

或者不用显式地指定

```
mysql> select * from t1 left join t2 on t1.n1 = t2.n2 where  t2.m2 = 2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
+------+------+------+------+
```

外连接中，被驱动表的列在 where 中被指定为不能为 null，被称为 空值拒绝（reject empty）。

这时内连接和外连接可以相互转化，便于连接顺序优化。

## 子查询优化

### 子查询语法

一个查询语句的某个位置可以有另一个查询语句，出现在一个查询语句某个位置的查询语句被称为`子查询`。某个位置包含另一个查询语句的被称为 `外层查询`。子查询可以出现在外层查询的各种位置

- select 子句

  ```
  mysql> select (select m1 from t1 limit 1);
  +-----------------------------+
  | (select m1 from t1 limit 1) |
  +-----------------------------+
  |                           1 |
  +-----------------------------+
  1 row in set (0.00 sec)
  
  mysql> select (select m1 from t1 limit 2);
  ERROR 1242 (21000): Subquery returns more than 1 row
  ```

- from 子句

  ```
  mysql> select m,n from (select m2 + 1 as m, n2 as n from t2 where m2 > 2);
  ERROR 1248 (42000): Every derived table must have its own alias
  mysql> select m,n from (select m2 + 1 as m, n2 as n from t2 where m2 > 2) as t;
  +------+------+
  | m    | n    |
  +------+------+
  |    4 | c    |
  |    5 | d    |
  +------+------+
  2 rows in set (0.00 sec)
  ```

  from 子句的子查询本质上相当于一个表，子查询的结果集组成的表被称为派生表

- where 或 on 子句

  ```
  mysql> select * from t1 where m1 in (select m2 from t2);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  |    3 | c    |
  +------+------+
  ```

- order by 子句

  没有实际意义

- group by 子句

  没有实际意义

#### 按结果集区分子查询

- 标量子查询

  返回单一值

  ```
  mysql> select (select m1 from t1 limit 1);
  +-----------------------------+
  | (select m1 from t1 limit 1) |
  +-----------------------------+
  |                           1 |
  +-----------------------------+
  ```

  ```
  mysql> select * from t1 where m1 = (select min(m2) from t2);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  +------+------+
  ```

- 行子查询

  返回一条记录，但这一行包含多个列

  ```
  mysql> select * from t1 where (m1,n1) = (select m2,n2 from t2 limit 1);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  +------+------+
  ```

- 列子查询

  查询出一个列的数据，但是要包含多条记录

  ```
  mysql> select * from t1 where m1 in (select m2 from t2);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  |    3 | c    |
  +------+------+
  
  ```

- 表子查询

  子查询结果包含多条记录，又包含多个列

  ```
  mysql> select * from t1 where (m1,n1) in (select m2,n2 from t2 );
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  |    3 | c    |
  +------+------+
  ```

#### 按与外层查询的关系来区分子查询

- 不相关子查询

  子查询可以单独运行出结果，而不依赖外层查询。上面的都是

- 相关子查询

  子查询的执行依赖外层查询

  ```
  mysql> select * from t1 where (m1,n1) in (select m2,n2 from t2  where n1 = n2);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  |    3 | c    |
  +------+------+
  ```

#### 子查询在布尔表达式的使用

- 使用 = > !=  作为布尔表达式的操作符

  ```
  操作数 comparison_operator （子查询）
  ```

  这里的子查询只能是标量子查询或行子查询，查询结果只能是一条记录或一个单一的值

  ```
  SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
  ```

  ```
  SELECT * FROM t1 WHERE （m1,n1) = (SELECT m2,n2 FROM t2);
  ```

- in / any /some /all 子查询

  - in

    ```
    操作数 in （子查询）
    ```

    ```
    SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
    ```

    

  - any / some

  - all

- exists 子查询