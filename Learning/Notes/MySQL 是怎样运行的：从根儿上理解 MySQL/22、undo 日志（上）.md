# 22、undo 日志（上）

> https://juejin.cn/book/6844733769996304392/section/6844733770067607566

## 事务回滚的需求

数据库中的回滚跟`悔棋`差不多，你插入了一条记录，`回滚`操作对应的就是把这条记录删除掉；你更新了一条记录，`回滚`操作对应的就是把该记录更新为旧值；你删除了一条记录，`回滚`操作对应的自然就是把该记录再插进去

不同类型的操作产生的`undo日志`的格式也是不同的

## 事务id

### 给事务分配id的时机

- 在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。
- 在读写事务中可以对表执行增删改查操作。

对于事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个`事务id`，否则的话也是不分配`事务id`的

### 事务id是怎么生成的

具体策略如下：

- 服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个`事务id`时，就会把该变量的值当作`事务id`分配给该事务，并且把该变量自增1。
- 每当这个变量的值为`256`的倍数时，就会将该变量的值刷新到`Max Trx ID`的属性处，
- 当系统下一次重新启动时，`Max Trx ID`属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量

这样就可以保证整个系统中分配的`事务id`值是一个递增的数字。先被分配`id`的事务得到的是较小的`事务id`，后被分配`id`的事务得到的是较大的`事务id`。

### trx_id隐藏列

聚簇索引会自动添加名为trx_id、roll_pointer的隐藏列,就是某个对这个聚簇索引记录做改动的`事务id`

## undo日志的格式

一般每对一条记录做一次改动，就对应着一条`undo日志`。

一个事务可能需要记录很多条对应的`undo日志`，这些`undo日志`会被从`0`开始编号，这个编号也被称之为`undo no`

这些`undo日志`是被记录到类型为`FIL_PAGE_UNDO_LOG`的页面中

```
mysql> CREATE TABLE undo_demo (
    ->     id INT NOT NULL,
    ->     key1 VARCHAR(100),
    ->     col VARCHAR(100),
    ->     PRIMARY KEY (id),
    ->     KEY idx_key1 (key1)
    -> )Engine=InnoDB CHARSET=utf8;
Query OK, 0 rows affected (0.03 sec)
```

```
mysql>  SELECT * FROM information_schema.innodb_sys_tables WHERE name = 'demo/undo_demo';
+----------+----------------+------+--------+-------+-------------+------------+---------------+------------+
| TABLE_ID | NAME           | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE | SPACE_TYPE |
+----------+----------------+------+--------+-------+-------------+------------+---------------+------------+
|       76 | demo/undo_demo |   33 |      6 |    57 | Barracuda   | Dynamic    |             0 | Single     |
+----------+----------------+------+--------+-------+-------------+------------+---------------+------------+
```

TABLE_ID 76

### INSERT操作对应的undo日志

如果希望回滚插入操作，那么把这条记录删除就好了，也就是说在写对应的`undo`日志时，主要是把这条记录的主键信息记上。所以设计`InnoDB`的大叔设计了一个类型为`TRX_UNDO_INSERT_REC`的`undo日志`

如果记录中的主键只包含一个列，那么在类型为`TRX_UNDO_INSERT_REC`的`undo日志`中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来

```
mysql> begin;
Query OK, 0 rows affected (0.00 sec)
mysql> insert into undo_demo(id, key1, col) values(1, 'AWM', 'aw'),(2, 'm416', 'm');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
mysql> commit;
```

- 第一条`undo日志`的`undo no`为`0`，记录主键占用的存储空间长度为`4`，真实值为`1`
- 第二条`undo日志`的`undo no`为`1`，记录主键占用的存储空间长度为`4`，真实值为`2`。

#### roll_pointer隐藏列的含义

聚簇索引记录中的一个隐藏列，指向记录对应的`undo日志`的一个指针。指向记录对应的undo日志。

`undo日志`被存放到了类型为`FIL_PAGE_UNDO_LOG`的页面中。

### DELETE操作对应的undo日志

这个删除的过程需要经历两个阶段：

- 仅仅将记录的`delete_mask`标识位设置为`1`。这个阶段称之为`delete mark`。
- 当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从`正常记录链表`中移除，并且加入到`垃圾链表`中

### UPDATE操作对应的undo日志

#### 不更新主键的情况

- 就地更新（in-place update）

  如果每个列在更新前后占用的存储空间一样大，那么就可以进行`就地更新`

  ```
  UPDATE undo_demo 
      SET key1 = 'P92', col = '手枪' 
      WHERE id = 2;
  ```

  两个列更改前后的字节不一样，key1 由 4个字节，变为 3 个字节

  ```
  UPDATE undo_demo 
      SET key1 = 'M249', col = '机枪' 
      WHERE id = 2;
  ```

  两个列更改前后的字节一样

- 先删除掉旧记录，再插入新记录

  如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录删除掉，然后再创建一条新的记录。

#### 更新主键的情况

- 将旧记录进行`delete mark`操作
- 根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中